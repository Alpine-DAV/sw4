//  SW4 LICENSE
// # ----------------------------------------------------------------------
// # SW4 - Seismic Waves, 4th order
// # ----------------------------------------------------------------------
// # Copyright (c) 2013, Lawrence Livermore National Security, LLC.
// # Produced at the Lawrence Livermore National Laboratory.
// #
// # Written by:
// # N. Anders Petersson (petersson1@llnl.gov)
// # Bjorn Sjogreen      (sjogreen2@llnl.gov)
// #
// # LLNL-CODE-643337
// #
// # All rights reserved.
// #
// # This file is part of SW4, Version: 1.0
// #
// # Please also read LICENCE.txt, which contains "Our Notice and GNU General Public License"
// #
// # This program is free software; you can redistribute it and/or modify
// # it under the terms of the GNU General Public License (as published by
// # the Free Software Foundation) version 2, dated June 1991.
// #
// # This program is distributed in the hope that it will be useful, but
// # WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
// # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
// # conditions of the GNU General Public License for more details.
// #
// # You should have received a copy of the GNU General Public License
// # along with this program; if not, write to the Free Software
// # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
#include "mpi.h"

#include "SfileHDF5.h"
#include "MaterialSfile.h"

#ifdef USE_HDF5
#include "hdf5.h"
#endif

using std::cout;

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_topo(const std::string& filename, EW& ew, 
    Sarray& gridElev, float_sw4& lon0, float_sw4& lat0, float_sw4& azim, 
    float_sw4& hh)
{
#ifdef USE_HDF5
   bool debug=false;
   char msg[1000];
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_topo" << endl;

   // Timers
   double time_start = MPI_Wtime();
   // Open file
   hid_t mpiprop_id = H5Pcreate(H5P_DATASET_XFER);
   H5Pset_dxpl_mpio(mpiprop_id, H5FD_MPIO_INDEPENDENT);

   MPI_Comm comm = MPI_COMM_WORLD;
   MPI_Info info = MPI_INFO_NULL;
   hid_t prop_id = H5Pcreate(H5P_FILE_ACCESS);
   H5Pset_fapl_mpio(prop_id, comm, info);
   hid_t file_id = H5Fopen(const_cast<char *>(filename.c_str()),
      H5F_ACC_RDONLY, prop_id);
   if (file_id < 0)
   {
      cout << "Could not open hdf5 file: " << filename << endl;
      MPI_Abort(comm, file_id);
   }
   H5Pclose(prop_id);

   // Header
   // Read all the metadata from the file
   if (debug && (myRank == 0))
      cout << "Reading hdf5 metadata for file: " << filename << endl;

   // Temp array for reading slices
   float *window_array = NULL;
   herr_t ierr;
   //   Horizontal grid spacing - h constant in horizontal, double (avoids roundoff for large nx), assume 2x coarsening with grid interfaces (watch out for mod 2 coarsening), make sure it’s self-consistent
   hsize_t dim = 1;
   float lonlataz[3] = {-1,-1,-1};
   float h;
   vector<int> patch_nk;
   read_sfile_header(file_id, mpiprop_id, h, lonlataz, patch_nk);
   hh = h;
   int npatch = patch_nk.size();
   ASSERT(npatch > 0);
   lon0 = lonlataz[0];
   lat0 = lonlataz[1];
   azim = lonlataz[2];
   CHECK_INPUT( fabs(azim - ew.getGridAzimuth()) < 1e-6, 
       "ERROR: Rfile azimuth must be equal to coordinate system azimuth" <<
		   " azimuth on rfile = " << azim << " azimuth of coordinate sytem = "
       << ew.getGridAzimuth() );

   //   TODO:
   //   Filetype - string, to make sure it’s this type of file, “SW4 Matfile”
   //   Filetype version - string, to make sure we know how to read it, “v1”
   //   Description metadata - string (ex: “Generated by SW4 from berkeley.rfile at …”)
   //   Proj4 string (see rfile spec)

   bool topoOnly = true;
   vector<Sarray*> interfaces(npatch+1);
   interfaces[npatch] = &gridElev;
   read_sfile_interface_group(file_id, mpiprop_id, topoOnly, interfaces);

   // Close file
   if (debug)
   {
     cout << "Rank " << myRank << " closing mpiprop..." << endl;
     cout.flush();
   }
   H5Pclose(mpiprop_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closing file..." << endl;
     cout.flush();
   }
   H5Fclose(file_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closed file..." << endl;
     cout.flush();
   }
 
   // Timers
   double time_end = MPI_Wtime();
   if (debug && (myRank == 0))
      cout << "Sfile::read_sfile_topo, time to read topo file: " << time_end - time_start << " seconds." << endl;
   cout.flush();

#endif // if USE_HDF5
}

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_material(const std::string &filename, 
    EW &ew, MaterialSfile &model, vector<Sarray>& materials,
    vector<Sarray>& interfaces)
{
#ifdef USE_HDF5
   bool debug=true;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_material" << endl;

   // Timers
   double time_start = MPI_Wtime();
   // Open file
   hid_t mpiprop_id = H5Pcreate(H5P_DATASET_XFER);
   H5Pset_dxpl_mpio(mpiprop_id, H5FD_MPIO_INDEPENDENT);

   MPI_Comm comm = MPI_COMM_WORLD;
   MPI_Info info = MPI_INFO_NULL;
   hid_t prop_id = H5Pcreate(H5P_FILE_ACCESS);
   H5Pset_fapl_mpio(prop_id, comm, info);
   hid_t file_id = H5Fopen(const_cast<char *>(filename.c_str()),
      H5F_ACC_RDONLY, prop_id);
   if (file_id < 0)
   {
      cout << "Could not open hdf5 file: " << filename << endl;
      MPI_Abort(comm, file_id);
   }
   H5Pclose(prop_id);

   // Header - read all the metadata to the file
   if (debug && (myRank == 0))
      cout << "Reading hdf5 metadata for file: " << filename << endl;
   float h;
   vector<int> patch_nk;
   float lonlataz[3];
   read_sfile_header(file_id, mpiprop_id, h, lonlataz, patch_nk);
   int npatch = patch_nk.size();
   ASSERT(npatch > 0);

   bool topoOnly = false;
   interfaces.resize(npatch+1);
   vector<Sarray*> intf(npatch+1,NULL);
   for (int p=0; p <= npatch; ++p)
      intf[p] = &interfaces[p];
   read_sfile_interface_group(file_id, mpiprop_id, topoOnly, intf);

   // TODO - implement pseudocode:
   // - Read the material data into mMaterial
   // - Create top/bottom interfaces for interpolation?
   materials.resize(npatch+1);
   read_sfile_material_group(file_id, mpiprop_id, materials);

   // TODO - anything else after we've read them?

   // Close file
   if (debug)
   {
     cout << "Rank " << myRank << " closing mpiprop..." << endl;
     cout.flush();
   }
   H5Pclose(mpiprop_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closing file..." << endl;
     cout.flush();
   }
   H5Fclose(file_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closed file..." << endl;
     cout.flush();
   }

   // Timers
   double time_end = MPI_Wtime();
   if (debug && (myRank == 0))
      cout << "Sfile::read_sfile_material, time to read material file: " 
         << time_end - time_start << " seconds." << endl;
   cout.flush();

#endif // if USE_HDF5
}

//-----------------------------------------------------------------------
void SfileHDF5::write_sfile(const std::string &file,
  const std::string &path, EW &ew, MaterialRfile &model, 
  vector<float_sw4>& mr_depth, int horizontalInterval)
{
#ifdef USE_HDF5
   bool debug = false;
   // Timers
   double time_start = MPI_Wtime();

   MPI_Comm comm = MPI_COMM_WORLD;
   MPI_Info info = MPI_INFO_NULL;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

   char msg[1000];
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::write_sfile" << endl;
   string filename = path + "/" + file;

   // Double-check that this horizontal interval for sampling works
   int hs = horizontalInterval;
   ASSERT((hs == 1) || (hs == 2) || (hs ==4));
   if (debug && (myRank==0))
      cout << "Subsampling at horizontal interval = " << hs << endl;

   // Locate patches/interfaces, figure out depth vs. grid-k index ranges
   int ngrids = ew.mNumberOfGrids;
   for (int g=0; g < ngrids; ++g)
     if (debug)
        cout << "Grid " << g << " zmin=" << ew.m_zmin[g] << endl;
   vector<vector<sfile_breaks> > patch_breaks;
   vector<int> patch_nk;
   calculate_patches(ew, mr_depth, horizontalInterval, patch_breaks, patch_nk);
   int npatch = patch_breaks.size();

   // Open file
   hid_t mpiprop_id = H5Pcreate(H5P_DATASET_XFER);
   H5Pset_dxpl_mpio(mpiprop_id, H5FD_MPIO_INDEPENDENT);

   hid_t prop_id = H5Pcreate(H5P_FILE_ACCESS);
   H5Pset_fapl_mpio(prop_id, comm, info);
   hid_t file_id = H5Fcreate(const_cast<char *>(filename.c_str()),
                             H5F_ACC_TRUNC, H5P_DEFAULT, prop_id);
   if (file_id < 0)
   {
      cout << "Could not open hdf5 file: " << filename << endl;
      MPI_Abort(comm, file_id);
   }
   H5Pclose(prop_id);

   // Add all the header metadata to the file
   if (debug && (myRank == 0))
      cout << "Writing hdf5 metadata for file: " << filename << endl;

   // Horizontal grid spacing - h constant in horizontal, double (avoids roundoff for large nx), assume 2x coarsening with grid interfaces (watch out for mod 2 coarsening), make sure it’s self-consistent
   float h = ew.mGridSize[ngrids-1] * hs * (float) pow(2,npatch-1);
   float lonlataz[3] = {ew.getLonOrigin(), ew.getLatOrigin(), 
     ew.getGridAzimuth()};
   // Patches are in bottom-up order, patch_breaks interfaces are top-down
   write_sfile_header(file_id, mpiprop_id, h, lonlataz, patch_nk);

   vector<float*> z_bot, z_top;
   write_sfile_interfaces(file_id, mpiprop_id, ew, patch_breaks, z_bot, z_top);
   ASSERT((z_bot.size() == npatch) && (z_top.size() == npatch));

   write_sfile_materials(file_id, mpiprop_id, ew, model, patch_breaks, 
       patch_nk, z_bot, z_top);

   for (int i=0; i<z_bot.size(); ++i)
   {
     delete[] z_bot[i];
     delete[] z_top[i];
   }

   // Close file
   if (debug)
   {
     cout << "Rank " << myRank << " closing mpiprop..." << endl;
     cout.flush();
   }
   H5Pclose(mpiprop_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closing file..." << endl;
     cout.flush();
   }
   H5Fclose(file_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closed file..." << endl;
     cout.flush();
   }

   // Timers
   double time_end = MPI_Wtime();
   if (debug && (myRank == 0))
      cout << "Sfile::write_sfile, time to write material file: " << time_end - time_start << " seconds." << endl;
   cout.flush();

#endif // if USE_HDF5
}

//-----------------------------------------------------------------------
void SfileHDF5::calculate_patches(EW& ew, vector<float_sw4>& mr_depth, 
    int hs, vector<vector<sfile_breaks> >& patch_breaks, vector<int>& patch_nk)
{
   const bool debug=false;
   float_sw4 tol = 1e-5;
   int ngrids = ew.mNumberOfGrids;
   vector<sfile_breaks> brks;
   sfile_breaks b = {.p = -1, .g = ngrids-1, .kb = 1, .ke = -1};
   float_sw4 gzmax = ew.m_zmin[0] + ew.mGridSize[0]*(ew.m_global_nz[0]-1);
   for (int d=0; d < mr_depth.size(); ++d)
     if (mr_depth[d] > (gzmax-tol)) // Below the bottom of the domain, truncate
       mr_depth.resize(d+1);
   mr_depth.push_back(gzmax); // Add the bottom

   int npatch = mr_depth.size();
   patch_breaks.resize(npatch);
   for (int d=0; d < npatch; ++d)
   {
     b.p = npatch-1-d; // patch above this depth
     float_sw4 depth = mr_depth[d];
     // Loop down through the grids to find the break, appending as we go
     for (int g=b.g; g >=0; --g)
     {
       b.g = g;
       // Sampling factor gets smaller as we coarsen patches
       int sfactor = (npatch-1-b.p)-(ngrids-2-min(ngrids-2,b.g));
       ASSERT(sfactor >= 0);
       b.hs = pow(2,sfactor)*hs;
       b.vs = pow(2,sfactor);
       int gkmax = ew.m_global_nz[g];
       float_sw4 hv = ew.mGridSize[g]; // vertical grid spacing
       // Topo grid
       float_sw4 zmin, zmax;
       if (ew.m_topography_exists && (g==(ngrids-1)))
       {
          zmin = 0; // depth from top
          zmax = ew.m_zmin[g-1]; // next cart grid
       }
       else // Cartesian grid
       {
          zmin = ew.m_zmin[g];
          zmax = zmin + (gkmax-1)*hv;
       }
       int mk = floor(tol + (depth - zmin)/hv)+1; // approximate k re: hv
       // We treat top curv + next cart grid as one grid
       if (depth < (zmax+tol))
       {  
          // Where is the break?
          if (mk <= gkmax)
          {  // Before the end of curv grid
             b.ke = mk;
             brks.push_back(b);
             b.kb = mk;
             b.ke = -1;
             if (mk == gkmax) // At the end, go to the next grid
             {
                b.g--;
                b.kb = 1;
             }
             break; // go to next depth entry
          }
       }
       else // depth > (zmax+tol)
       {  // past end of this grid, continue
          b.ke = gkmax;
          brks.push_back(b);
          if (b.g > 0) // Only if there is another grid to search
          {
            b.kb = 1;
            b.ke = -1;
          }
          continue; // keep looking next grid
       }
     }
   }

   // Go back through and bin by patch
   for (int b=0; b < brks.size(); ++b)
   {
     ASSERT((brks[b].hs > 0) && (brks[b].vs > 0));
     patch_breaks[brks[b].p].push_back(brks[b]);
   }

   npatch = patch_breaks.size();
   patch_nk.resize(npatch);
   for (int p=0; p<npatch; ++p)
   {
     float nk = 0;
     vector<sfile_breaks>& pbrk = patch_breaks[p];
     for (int b=0; b < pbrk.size(); ++b) // Add number of points
     {
       int gk = pbrk[b].ke-pbrk[b].kb; 
       float k = (gk+1)/pbrk[b].vs;
       nk += k; // rough number of vs
       if (b > 0) --nk; // Remove 1 point for overlap between grids
       patch_nk[p] = floor(nk);
       if (debug)
           cout << "Patch " << pbrk[b].p << " above depth " 
             << mr_depth[npatch-1-pbrk[b].p] << ", accum nk=" << patch_nk[p]
             << ", k=" << k << ", in grid " << pbrk[b].g
             << ", index range (" << pbrk[b].kb << ", " << pbrk[b].ke 
             << "), hs = " << pbrk[b].hs << ", vs= " << pbrk[b].vs << endl;
       // ASSERT(gk >= pbrk[b].vs); // Not necessary with interpolation?
       ASSERT((gk+1) >= 2); // At least 2 points
     }
   }
}

//-----------------------------------------------------------------------
#ifdef USE_HDF5
void SfileHDF5::write_sfile_header(hid_t file_id, hid_t mpiprop_id, 
    const float& h_coarse, const float (&lonlataz)[3], vector<int>& patch_nk)
{
   //   TODO:
   //   Filetype - string, to make sure it’s this type of file, “SW4 Matfile”
   //   Filetype version - string, to make sure we know how to read it, “v1”
   //   Description metadata - string (ex: “Generated by SW4 from berkeley.rfile at …”)
   //   Proj4 string (see rfile spec)
  hsize_t dim = 1;
  hid_t dataspace_id = H5Screate_simple(1, &dim, NULL);
  hid_t dataset_id = H5Dcreate2(file_id, "Coarsest horizontal grid spacing",
      H5T_IEEE_F32LE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  herr_t ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL, 
      mpiprop_id, &h_coarse);
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);

  // Longitude, latitude, azimuth
  dim = 3;
  dataspace_id = H5Screate_simple(1, &dim, NULL);
  dataset_id = H5Dcreate2(file_id, "Origin longitude, latitude, azimuth",
      H5T_IEEE_F32LE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL,
                  mpiprop_id, lonlataz);
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);

  //   Ngrids - int, number of 3D grids in the file
  dim = 1;
  int npatch = patch_nk.size();
  dataspace_id = H5Screate_simple(1, &dim, NULL);
  dataset_id = H5Dcreate2(file_id, "ngrids", H5T_STD_I32LE,
      dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  ierr = H5Dwrite(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL,
      mpiprop_id, &npatch);
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);

  //   Number of grid points in vertical for each grid (needed for topo command)
  dim = npatch;
  dataspace_id = H5Screate_simple(1, &dim, NULL);
  dataset_id = H5Dcreate2(file_id, "grid nz", H5T_STD_I32LE,
      dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  ierr = H5Dwrite(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL, 
      mpiprop_id, patch_nk.data());
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);
}

//-----------------------------------------------------------------------
void SfileHDF5::write_sfile_interfaces(hid_t file_id, hid_t mpiprop_id, 
    EW& ew, vector<vector<sfile_breaks> >& patch_breaks,
    vector<float*>& z_bot, vector<float*>& z_top)
{
   const bool debug=false;
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

   char msg[1000];
   hsize_t dim = 1;
   herr_t ierr;
   hid_t dataspace_id;
   hid_t dataset_id;

   // Topo/interface section
   //     Even for cartesian, store them all, including the bottom
   //     For each grid, its lower interface is at the resolution of the lower grid (avoids interpolation, is a saw-tooth like interpolation)
   //     (Double-check the code, to make sure you don’t interpolate a coarsened interface for the grid lines)
   //   (Note:) Absolute SL topo elevation (positive up)

   // Create the z_interface group
   hid_t group_id;
   char group_name[] = "Z_interfaces";
   group_id = H5Gcreate(file_id, group_name, H5P_DEFAULT,
                        H5P_DEFAULT, H5P_DEFAULT);
   // Write 2D patches just for topo “interfaces” - elevation for top and any internal grid boundaries, as well as the bottom.
   int npatch = patch_breaks.size();
   int ngrids = ew.mNumberOfGrids;
   z_bot.resize(npatch, NULL);
   z_top.resize(npatch, NULL);
   for (int f = 0; f <= npatch; ++f) // f is interface index
   {
      int p = max(0, f-1);
      vector<sfile_breaks>& brks = patch_breaks[p];
      int hs,gk,g=brks[0].g;
      for (int b=0; b < brks.size(); ++b)
         if ((f > 0) && (brks[b].g >= g))
         {  // Select the top of patch p
            g = brks[b].g;
            gk = brks[b].kb; // index for top interface
            hs = brks[b].hs; // horizontal sampling for interface
         }
         else if ((f == 0) && (brks[b].g <= g))
         {  // bottom of domain, f=0
            g = brks[b].g;
            gk = brks[b].ke; // index for bottom interface
            hs = brks[b].hs; // horizontal sampling for interface
         }

      if (debug)
      {
         sprintf(msg, "Interface %d, from grid %d index %d \n", f, g, gk);
         cout << msg;
         cout.flush();
      }

      // Z interface values
      hsize_t z_dims = 2;
      hsize_t slice_dims[2], global_dims[2], chunk_dims[2];
      // This processor's horizontal window, interior points
      slice_dims[0] = (ew.m_iEndInt[g]-1)/hs - (ew.m_iStartInt[g]-1)/hs + 1;
      slice_dims[1] = (ew.m_jEndInt[g]-1)/hs - (ew.m_jStartInt[g]-1)/hs + 1;
      // printf("myRank = %d, ew.m_iEndInt[ig]  = %d , ew.m_iStartInt[ig] = %d \n", myRank, ew.m_iEndInt[ig], ew.m_jStartInt[ig]);
      global_dims[0] = (ew.m_global_nx[g]-1)/hs + 1;
      global_dims[1] = (ew.m_global_ny[g]-1)/hs + 1;
      // All ranks must have the same chunk size
      // slice_dims[0] = 10;
      // slice_dims[1] = 10;
      // chunk_dims[0] = 10;
      // chunk_dims[1] = 10;

      // Allocate our tmp arrays on first pass
      size_t npts = (size_t)(slice_dims[0] * slice_dims[1]);
      if (z_bot[p] == NULL)
      {
        z_bot[p] = new float[npts];
        z_top[p] = new float[npts];
      }

      // Modify dataset creation properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      ierr = H5Pset_chunk(prop_id, z_dims, slice_dims);
      // Create dataset for z field
      hid_t dataspace_id = H5Screate_simple(z_dims, global_dims, NULL);
      char buff[100];
      sprintf(buff, "z_values_%d", f);
      // FIXME - uncommmenting these lines makes it hang in parallel
      // #if 0
      dataset_id = H5Dcreate2(group_id, buff, H5T_IEEE_F32LE,
                              dataspace_id, H5P_DEFAULT, prop_id, H5P_DEFAULT);
      if (dataset_id < 0)
      {
         cout << "SfileHDF5::write_sfile_interfaces: "
           << "Could not create dataset!" << endl;
         MPI_Abort(comm, file_id);
      }
      // FIXME - Uncomment these lines to see MPI parallel hang
      // add grid index attribute
      hid_t space_id = H5Screate(H5S_SCALAR);
      hid_t attr_id = H5Acreate(dataset_id, "interface_id", H5T_STD_I32LE,
                                space_id, H5P_DEFAULT, H5P_DEFAULT);
      H5Awrite(attr_id, H5T_STD_I32LE, &f);
      ierr = H5Aclose(attr_id);
      ierr = H5Sclose(space_id);

      // TODO - write the data, if topo, or generate for cart
      hsize_t start[2] = {-1, -1};
      start[0] = (ew.m_iStartInt[g]-1)/hs + 1 - 1;
      start[1] = (ew.m_jStartInt[g]-1)/hs + 1 - 1;
      if (debug)
      {
         sprintf(msg, "Rank %d, selecting grid %d z hyperslab = %d %d, size [%d,%d] in [%d,%d] \n",
                 myRank, g, (int)start[0], (int)start[1],
                 (int)slice_dims[0], (int)slice_dims[1],
                 (int)global_dims[0], (int)global_dims[1]);
         cout << msg;
         cout.flush();
      }
      hid_t window_id = H5Screate_simple(z_dims, slice_dims, NULL);
      ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, NULL,
          slice_dims, NULL);
      if (ierr < 0)
      {
        cout << "Error from z H5Sselect_hyperslab" << endl;
        MPI_Abort(comm,ierr);
      }
      if (debug)
      {
        char msg[1000];
        sprintf(msg, "Writing z array Rank %d\n", myRank);
        cout << msg;
        cout.flush();
      }

      patch_interface(z_top[p], slice_dims, true, brks, ew);
      patch_interface(z_bot[p], slice_dims, false, brks, ew);
      float* z_vals = (f!=0) ? z_top[p] : z_bot[p];

#if 0
      // Copy top topo of grid values into window_array
      if (ew.m_topography_exists && (g==(ngrids-1)))
      {
        // cout << "Interface " << g << ", copying from grid " << ig << ", index " << k << endl;
#pragma omp parallel for
        for( int i=0 ; i < slice_dims[0]; i++ )
        for( int j=0 ; j < slice_dims[1]; j++ )
        {
           const size_t ind = j+slice_dims[1]*i; // only 2D slice
           const int gi = (i*hs + ew.m_iStartInt[g]);
           const int gj = (j*hs + ew.m_jStartInt[g]);
           z_top[p][ind]= ew.mZ(1,gi,gj,gk);
           // window_array[ind]= (double) ind; // for testing
        }
      }
      else // this is a cartesian interface, fill with a constant z
      {
        for( int i=0 ; i < slice_dims[0]; i++ )
        for( int j=0 ; j < slice_dims[1]; j++ )
        {
           const size_t ind = j+slice_dims[1]*i; // only 2D slice
           z_top[p][ind]= ew.m_zmin[g] + (gk-1)*ew.mGridSize[g];
           if (f==0)
             z_bot[p][ind]= ew.m_zmin[g] + (gk-1)*ew.mGridSize[g];
           // window_array[ind]= (double) ind; // for testing
        }
      }
#endif //#if 0
      ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, window_id, dataspace_id,
          mpiprop_id, (f!=0) ? z_top[p] : z_bot[p]);
      if (ierr < 0)
      {
        cout << "Error from SfileHDF5 topo H5Dwrite " << endl;
        MPI_Abort(comm,ierr);
      }
      ierr = H5Sclose(window_id);
      ierr = H5Dclose(dataset_id);
      ierr = H5Sclose(dataspace_id);
      ierr = H5Pclose(prop_id);
   }
   ierr = H5Gclose(group_id); // Z_interface group
}

//-----------------------------------------------------------------------
void SfileHDF5::write_sfile_materials(hid_t file_id, hid_t mpiprop_id, EW& ew, 
    MaterialRfile &model, vector<vector<sfile_breaks> >& patch_breaks,
    vector<int>& patch_nk, vector<float*>& z_bot, vector<float*>& z_top)
{
   const bool debug=false;
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

   char msg[1000];
   herr_t ierr;

   int nvars = (model.use_attenuation()) ? 5 : 3;
   int npatch = patch_breaks.size();
   int ngrids = ew.mNumberOfGrids;

   // Write the material data for each grid
   hid_t group_id = H5Gcreate(file_id, "Material_model", H5P_DEFAULT, 
       H5P_DEFAULT, H5P_DEFAULT);
   // Material output on each patch
   for (int p=0; p < npatch; p++)
   {
      // NB: these are stored in order of g high to g low
      vector<sfile_breaks>& brks = patch_breaks[p];
      int nk = patch_nk[p];

      // Write datasets from all the grids this patch intersects
      hsize_t dims = 3;
      hsize_t slice_dims[3], global_dims[3];
      if (debug)
      {
         char msg[1000];
         sprintf(msg, "Writing arrays for patch %d, rank %d\n", p, myRank);
         cout << msg;
         cout.flush();
      }
      // For each patch, add the material from sw4's grids
      char buff[100];
      sprintf(buff, "Material_model/grid_%d", p);
      hid_t grid_id = H5Gcreate(file_id, buff, H5P_DEFAULT, 
         H5P_DEFAULT, H5P_DEFAULT);
      // add grid id attribute to the grid group
      hid_t space_id = H5Screate(H5S_SCALAR);
      hid_t attr_id = H5Acreate(grid_id, "grid_id", H5T_STD_I32LE, 
          space_id, H5P_DEFAULT, H5P_DEFAULT);
      H5Awrite(attr_id, H5T_STD_I32LE, &p);
      ierr = H5Aclose(attr_id);
      ierr = H5Sclose(space_id);

      int g = brks[0].g; // Should be the first grid, thus the correct rez/pts
      // This processor's horizontal window, interior points only
      int hs = brks[0].hs;
      slice_dims[0] = (ew.m_iEndInt[g]-1)/hs - (ew.m_iStartInt[g]-1)/hs + 1;
      slice_dims[1] = (ew.m_jEndInt[g]-1)/hs - (ew.m_jStartInt[g]-1)/hs + 1;
      slice_dims[2] = nk;
      global_dims[0] = (ew.m_global_nx[g]-1)/hs+1;
      global_dims[1] = (ew.m_global_ny[g]-1)/hs+1;
      global_dims[2] = nk;
      hsize_t start[3]={-1,-1,-1};

      const char *field[] = {"Rho", "Cp", "Cs", "Qs", "Qp"};
      int nvars = (model.use_attenuation()) ? 5 : 3;

      // Modify dataset creation properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      herr_t ierr = H5Pset_chunk(prop_id, dims, slice_dims);
      // Create the variables for this grid
      for (int c=0; c < nvars; c++)
      {
        hid_t dataspace_id = H5Screate_simple(dims, global_dims, NULL);
        hid_t dataset_id = H5Dcreate2(grid_id, field[c], H5T_IEEE_F32LE,
          dataspace_id, H5P_DEFAULT, prop_id, H5P_DEFAULT);
        ierr = H5Sclose(dataspace_id);
        ierr = H5Dclose(dataset_id);
      }

      // Create temp arrays for this patch
      size_t ncols = (size_t)(slice_dims[0] * slice_dims[1]);
      size_t npts = (size_t)(slice_dims[0]*slice_dims[1]*slice_dims[2]);
      vector<float*> h5_array(nvars);
      for (int v=0; v < nvars; ++v)
        h5_array[v] = new float[npts];

      // int koffset = 0;
      // Do the interpolation
      for (int b=0; b < brks.size(); b++)
      {
        sfile_breaks& brk = brks[b];
        int g = brk.g;
        // TODO - is this the right window?
        brk.ib = ew.m_iStartInt[g];
        brk.ie = ew.m_iEndInt[g];
        brk.jb = ew.m_jStartInt[g];
        brk.je = ew.m_jEndInt[g];
        // Interopolate all variables
        Sarray* z = (ew.m_topography_exists && (g==ngrids-1)) ? &(ew.mZ) : NULL;
        material_interpolate(h5_array, z_bot[p], z_top[p], 
            slice_dims, brk, z, ew.m_zmin[g], ew.mGridSize[g], 
            ew.mRho[g], ew.mMu[g], ew.mLambda[g], ew.mQs[g], ew.mQp[g]);
        // Don't need this? koffset += (slice_dims[2]-1); // For overlap
      }

      // Do the hdf5 write in chunks
      // TODO - need to chunk!
      // chunk_dims[0] = 10;
      // chunk_dims[1] = 10;
      // chunk_dims[2] = 10;
      for (int v=0; v < nvars; v++)
      {
        hid_t dataset_id = H5Dopen2(grid_id, field[v], H5P_DEFAULT);
        hid_t dataspace_id = H5Dget_space(dataset_id);
        start[0] = 0;
        start[1] = 0;
        start[2] = 0;
        hid_t window_id = H5Screate_simple(dims, slice_dims, NULL);
        ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, 
            NULL, slice_dims, NULL);
        if (debug)
        {
           sprintf(msg, "Rank %d selecting %s for hyperslab = %d %d %d, size [%d,%d,%d] in [%d,%d,%d] \n",
              myRank, field[v], (int) start[0], (int) start[1], (int) start[2],
              (int) slice_dims[0], (int) slice_dims[1], (int) slice_dims[2],
              (int) global_dims[0], (int) global_dims[1], (int) global_dims[2]);
           cout << msg;
           cout.flush();
        }
        // Write this variable
        ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, window_id, 
             dataspace_id, mpiprop_id, h5_array[v]);
        if (ierr < 0)
        {
          cout << "Error from SfileHDF5 component H5Dwrite " << endl;
          MPI_Abort(comm,ierr);
        }
        ierr = H5Sclose(dataspace_id);
        ierr = H5Dclose(dataset_id);
        if (debug)
        {
          char msg[1000];
          sprintf(msg, "Wrote %s array, patch %d, rank %d\n", 
              field[v], p, myRank);
          cout << msg;
          cout.flush();
        }
      } // for v
      ierr = H5Pclose(prop_id);
      ierr = H5Gclose(grid_id); // Material_model_grid_XX group

      for (int v=0; v < nvars; v++)
      {
        delete[] h5_array[v];
        h5_array[v] = NULL;
      }
   }
   if (debug)
      cout << "Rank " << myRank << " closing group..." << endl;
   cout.flush();
   ierr = H5Gclose(group_id); // Material_model group
}


//-----------------------------------------------------------------------
void SfileHDF5::material_interpolate(vector<float*>& h5_array,
    float* zbot, float* ztop, hsize_t (&slice_dims)[3],
    sfile_breaks& brk, Sarray* gridz, float zmin, float gridh,
    Sarray& grho, Sarray& gmu, Sarray& glambda, Sarray& gqp, Sarray& gqs)
{
  const bool topo = (gridz != NULL);
  const float tol = gridh*1e-2; // relative
  const int nk = slice_dims[2];
  const int nvars = h5_array.size();
  // Loop over the grid, if we've stepped over a patch k point fill it in
#pragma omp parallel for
  for (int j=0; j < slice_dims[1]; ++j)
    for (int i=0; i < slice_dims[0]; ++i)
    {
      bool debug = false && (i==0) && (j==0);
      int gi = brk.ib + i*brk.hs;
      int gj = brk.jb + j*brk.hs;
      size_t ijh5 = j + slice_dims[1]*i;
      float zt = ztop[ijh5]; // smaller positive value of depth at top
      float zb = zbot[ijh5];
      float h = (zb - zt) / (float) (nk-1);
      if (debug)
        cout << "grid=" << brk.g << ", zt=" << zt
          << ", zb=" << zb << ", h=" << h << endl;
      // Walk every point, identify if we can interpolate from grid
      for (int gk=brk.kb; gk < brk.ke; ++gk)
      {
        float gz0 = (topo) ? gridz->Sarray::operator()(gi,gj,gk) 
          : (zmin + (gk-1)*gridh);
        float gz1 = (topo) ? gridz->Sarray::operator()(gi,gj,gk+1) 
          : (zmin + (gk)*gridh);
        int kmin = ceil((-tol + gz0 - zt)/h);
        int kmax = floor((-tol + gz1 - zt)/h);
        if (gk==(brk.ke-1)) // Catch any last points
          kmax = floor((tol + gz1 - zt)/h);
        float zmin = zt + kmin*h;
        float zmax = zt + kmax*h;
        if (zmin < (gz0-tol)) 
        {
          zmin = zt + kmin*h;
          kmin++;
        }
        if (zmax > (gz1+tol))
        {
          kmax--;
          zmax = zt + kmax*h;
        }
        if (debug)
          cout << "grid=" << brk.g << ", gk=" << gk 
            << ", gz0=" << gz0 << ", gz1=" << gz1 
            << ", kmin=" << kmin << ", kmax=" << kmax
            << ", zmin=" << zmin << ", zmax=" << zmax << endl;
        if ((kmin<0) || (kmax >= nk)) // out of range
          continue; 
        // TODO - add k indexing
        for (int k=kmin; k <= kmax; ++k)
        {
          // Do the interpolation to this k point
          float t = (zt + k*h - gz0) / (gz1 - gz0);
          float rho = (1-t)*grho(gi,gj,gk)+t*grho(gi,gj,gk+1);
          float mu = (1-t)*gmu(gi,gj,gk)+t*gmu(gi,gj,gk+1);
          float lambda = (1-t)*glambda(gi,gj,gk)+t*glambda(gi,gj,gk+1);
          float qp = (1-t)*gqp(gi,gj,gk)+t*gqp(gi,gj,gk+1);
          float qs = (1-t)*gqs(gi,gj,gk)+t*gqs(gi,gj,gk+1);
          size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
          h5_array[0][ijkh5]=rho; // rho, comp 0
          h5_array[1][ijkh5]=sqrt((2*mu + lambda)/rho); // cp, comp 1
          h5_array[2][ijkh5]=sqrt(mu/rho); // cs, comp 2
          if (nvars > 3)
          {
            h5_array[3][ijkh5]=qp; // qp, comp 3
            h5_array[4][ijkh5]=qs; // qs, comp 4
          }
        }
      }
#if 0
      // For testing
      for (int k=0; k < nk; ++k)
      {
        // size_t ijkh5 = i + slice_dims[0]*(j + slice_dims[1]*k);
        size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
        size_t ind = 1 + i + slice_dims[0]*(j + slice_dims[1]*k);
        h5_array[0][ijkh5]=ind;
        h5_array[1][ijkh5]=ind;
        h5_array[2][ijkh5]=ind;
        if (nvars > 3)
        {
          h5_array[3][ijkh5]=ind; // qp, comp 3
          h5_array[4][ijkh5]=ind; // qs, comp 4
        }
      }
#endif // #if 0
    }
}

//-----------------------------------------------------------------------
void SfileHDF5::patch_interface(float* z, hsize_t (&dims)[2], 
    bool top, vector<sfile_breaks>& pbrk, EW& ew)
{
  int nbrk=pbrk.size();
  sfile_breaks& brk = (top) ? pbrk[0] : pbrk[nbrk-1];
  int gk = (top) ? brk.kb : brk.ke;

  // Copy top topo of grid values into window_array
  int ngrids = ew.mNumberOfGrids;
  if (ew.m_topography_exists && (brk.g==(ngrids-1)))
  {
    // cout << "Interface " << g << ", copying from grid " << ig << ", index " << k << endl;
#pragma omp parallel for
    for( int i=0 ; i < dims[0]; i++ )
    for( int j=0 ; j < dims[1]; j++ )
    {
       const size_t ind = j+dims[1]*i; // only 2D slice
       const int gi = (i*brk.hs + ew.m_iStartInt[brk.g]);
       const int gj = (j*brk.hs + ew.m_jStartInt[brk.g]);
       z[ind]= ew.mZ(1,gi,gj,gk);
    }
  }
  else // this is a cartesian interface, fill with a constant z
  {
    for( int i=0 ; i < dims[0]; i++ )
    for( int j=0 ; j < dims[1]; j++ )
    {
       const size_t ind = j+dims[1]*i; // only 2D slice
       z[ind]= ew.m_zmin[brk.g] + (gk-1)*ew.mGridSize[brk.g];
    }
  }
}
 
//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_header(hid_t file_id, hid_t mpiprop_id, 
    float& h, float (&lonlataz)[3], vector<int>& patch_nk)
{
   bool debug=false;
   hid_t dataspace_id;
   hid_t dataset_id;
   herr_t ierr;
   // Only 1 rank needs to read these - then broadcast
   // if (myRank == 0)
   {
      dataset_id = H5Dopen2(file_id, "Coarsest horizontal grid spacing",
         H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, &h);
      ierr = H5Dclose(dataset_id);

      // Origin longitude, latitude, azimuth
      dataset_id = H5Dopen2(file_id, "Origin longitude, latitude, azimuth",
         H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, lonlataz);
      ierr = H5Dclose(dataset_id);

      //   Ngrids - int, number of 3D grids in the file
      int npatch;
      dataset_id = H5Dopen2(file_id, "ngrids", H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, &npatch);
      ierr = H5Dclose(dataset_id);

      patch_nk.resize(npatch,-1);
      dataset_id = H5Dopen2(file_id, "grid nz", H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, patch_nk.data());
      ierr = H5Dclose(dataset_id);
      ASSERT(patch_nk.size() == npatch);
      for (int p=0; p < npatch; ++p)
        ASSERT(patch_nk[p] > 1);

      h /= (float) pow(2,npatch-1);
      if (debug)
      {
        sfile_hdr hdr;
        hdr.ngrids = npatch;
        hdr.h = h;
        hdr.lon0 = lonlataz[0];
        hdr.lat0 = lonlataz[1];
        hdr.azim = lonlataz[2];
        cout << "horizontal grid spacing: " << hdr.h << endl;
        cout << "ngrids: " << hdr.ngrids << endl;
        cout << "longitude: " << hdr.lon0 << endl;
        cout << "latitude: " << hdr.lat0 << endl;
        cout << "azimuth: " << hdr.azim << endl;
        cout << endl;
      }
   }
}

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_interface_group(hid_t file_id, hid_t mpiprop_id, 
    bool topoOnly, vector<Sarray*>& intf)
{
   bool debug=false;
   char msg[1000];
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_interfaces" << endl;

   hid_t dataspace_id;
   hid_t dataset_id;
   herr_t ierr;

   char group_name[] = "Z_interfaces";
   // Open 2D just for top topo “interface”
   // int g = npatch;
   // int ig = ew.mNumberOfGrids-1; // TODO - if we're going to window reads
   int nintf = intf.size();
   ASSERT(nintf > 0);
   for (int f=(topoOnly) ? (nintf-1) : 0; f < nintf; ++f)
   {
      Sarray& gridElev = *intf[f];
      // Open the dataset for z field
      char buff[100];
      sprintf(buff, "/%s/z_values_%d", group_name, f);
      dataset_id = H5Dopen2(file_id, buff, H5P_DEFAULT);
      if (dataset_id < 0)
      {
         cout << "Could not open dataset: " << buff << endl;
         MPI_Abort(comm, file_id);
      }
      //  Read the size of the data set
      hid_t dataspace_id = H5Dget_space(dataset_id);
      const hsize_t z_dim = 2; // 2D data
      hsize_t dims[z_dim]; // 2D data
      H5Sget_simple_extent_dims(dataspace_id, dims, NULL);
      if (debug)
      {
        cout << "z grid " << f << " size (" << dims[0]
          << ", " << dims[1] << ")" << endl;
      }

      // Z interface values
      hsize_t slice_dims[z_dim], global_dims[z_dim];
      // Read all the points
      // TODO, this could be windowed for this processor
      global_dims[0] = dims[0];
      global_dims[1] = dims[1];
      slice_dims[0] = dims[0];
      slice_dims[1] = dims[1];
      // Allocate our tmp array on first pass, biggest grid
      gridElev.define(1,dims[0],1,dims[1],1,1);
      size_t npts = (size_t)(slice_dims[0] * slice_dims[1]);
      float window_array[npts];

      // Modify dataset read properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      ierr = H5Pset_chunk(prop_id, z_dim, slice_dims);

      // TODO - read the topo data
      hsize_t start[2] = {-1, -1};
      start[0] = 0;
      start[1] = 00;
      if (debug)
      {
         sprintf(msg, "Rank %d, selecting interface %d z hyperslab = %d %d, size [%d,%d] in [%d,%d] \n",
                 myRank, f, (int)start[0], (int)start[1],
                 (int)slice_dims[0], (int)slice_dims[1],
                 (int)global_dims[0], (int)global_dims[1]);
         cout << msg;
         cout.flush();
      }
      hid_t window_id = H5Screate_simple(z_dim, slice_dims, NULL);
      ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, NULL,
          slice_dims, NULL);
      if (ierr < 0)
      {
        cout << "Error from z H5Sselect_hyperslab" << endl;
        MPI_Abort(comm,ierr);
      }
      if (debug)
      {
        char msg[1000];
        sprintf(msg, "Reading z array Rank %d\n", myRank);
        cout << msg;
        cout.flush();
      }

      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, window_id, dataspace_id,
          mpiprop_id, window_array);
      if (ierr < 0)
      {
        cout << "Error from SfileHDF5 interface H5Dread " << endl;
        MPI_Abort(comm,ierr);
      }

      const int k=1;
      float d_min = 1e8;
      float d_max = -1e8;

#pragma omp parallel for
      for( int i=0 ; i < slice_dims[0]; i++ )
      for( int j=0 ; j < slice_dims[1]; j++ )
      {
         size_t ind = j+slice_dims[1]*i; // only 2D slice
         int gi = i + 1;
         int gj = j + 1;
         float depth = -window_array[ind]; // depth = -elev
         gridElev(gi,gj,k) = depth;
         d_min = min(depth, d_min);
         d_max = max(depth, d_max);
         // window_array[ind]= (double) ind; // for testing
      }
      if (debug)
        cout << "Topo depth min=" << d_min << ", max="  << d_max << endl;

      ierr = H5Pclose(prop_id);
      ierr = H5Dclose(dataset_id);
      ierr = H5Sclose(dataspace_id);
   }
}

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_material_group(hid_t file_id, hid_t mpiprop_id, 
    vector<Sarray>& matl)
{
   bool debug=true;
   char msg[1000];
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_material_group" << endl;


}

#endif // ifdef USE_HDF5


