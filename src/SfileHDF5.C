//  SW4 LICENSE
// # ----------------------------------------------------------------------
// # SW4 - Seismic Waves, 4th order
// # ----------------------------------------------------------------------
// # Copyright (c) 2013, Lawrence Livermore National Security, LLC.
// # Produced at the Lawrence Livermore National Laboratory.
// #
// # Written by:
// # N. Anders Petersson (petersson1@llnl.gov)
// # Bjorn Sjogreen      (sjogreen2@llnl.gov)
// #
// # LLNL-CODE-643337
// #
// # All rights reserved.
// #
// # This file is part of SW4, Version: 1.0
// #
// # Please also read LICENCE.txt, which contains "Our Notice and GNU General Public License"
// #
// # This program is free software; you can redistribute it and/or modify
// # it under the terms of the GNU General Public License (as published by
// # the Free Software Foundation) version 2, dated June 1991.
// #
// # This program is distributed in the hope that it will be useful, but
// # WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
// # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
// # conditions of the GNU General Public License for more details.
// #
// # You should have received a copy of the GNU General Public License
// # along with this program; if not, write to the Free Software
// # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
#include "mpi.h"

#include "SfileHDF5.h"
#include "MaterialSfile.h"
#include "Require.h"

#ifdef USE_HDF5
#include "hdf5.h"
#endif

using std::cout;

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_topo(const std::string& filename, EW& ew, 
    Sarray& gridElev, float_sw4& lon0, float_sw4& lat0, float_sw4& azim, 
    float_sw4& hh)
{
#ifdef USE_HDF5
   bool debug=false;
   char msg[1000];
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_topo" << endl;

   // Timers
   double time_start = MPI_Wtime();
   // Open file
   hid_t mpiprop_id = H5Pcreate(H5P_DATASET_XFER);
   H5Pset_dxpl_mpio(mpiprop_id, H5FD_MPIO_INDEPENDENT);

   MPI_Comm comm = MPI_COMM_WORLD;
   MPI_Info info = MPI_INFO_NULL;
   hid_t prop_id = H5Pcreate(H5P_FILE_ACCESS);
   H5Pset_fapl_mpio(prop_id, comm, info);
   hid_t file_id = H5Fopen(const_cast<char *>(filename.c_str()),
      H5F_ACC_RDONLY, prop_id);
   if (file_id < 0)
   {
      cout << "Could not open hdf5 file: " << filename << endl;
      MPI_Abort(comm, file_id);
   }
   H5Pclose(prop_id);

   // Header
   // Read all the metadata from the file
   if (debug && (myRank == 0))
      cout << "Reading hdf5 metadata for file: " << filename << endl;

   // Temp array for reading slices
   float *window_array = NULL;
   herr_t ierr;
   //   Horizontal grid spacing - h constant in horizontal, double (avoids roundoff for large nx), assume 2x coarsening with grid interfaces (watch out for mod 2 coarsening), make sure it’s self-consistent
   hsize_t dim = 1;
   float lonlataz[3] = {-1,-1,-1};
   float h;
   vector<int> patch_nk;
   read_sfile_header(file_id, mpiprop_id, h, lonlataz, patch_nk);
   hh = h;
   int npatch = patch_nk.size();
   ASSERT(npatch > 0);
   lon0 = lonlataz[0];
   lat0 = lonlataz[1];
   azim = lonlataz[2];
   CHECK_INPUT( fabs(azim - ew.getGridAzimuth()) < 1e-6, 
       "ERROR: Rfile azimuth must be equal to coordinate system azimuth" <<
		   " azimuth on rfile = " << azim << " azimuth of coordinate sytem = "
       << ew.getGridAzimuth() );

   //   TODO:
   //   Filetype - string, to make sure it’s this type of file, “SW4 Matfile”
   //   Filetype version - string, to make sure we know how to read it, “v1”
   //   Description metadata - string (ex: “Generated by SW4 from berkeley.rfile at …”)
   //   Proj4 string (see rfile spec)

   bool topoOnly = true;
   vector<Sarray*> interfaces(npatch+1);
   interfaces[npatch] = &gridElev;
   read_sfile_interface_group(file_id, mpiprop_id, topoOnly, interfaces);

   // Close file
   if (debug)
   {
     cout << "Rank " << myRank << " closing mpiprop..." << endl;
     cout.flush();
   }
   H5Pclose(mpiprop_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closing file..." << endl;
     cout.flush();
   }
   H5Fclose(file_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closed file..." << endl;
     cout.flush();
   }
 
   // Timers
   double time_end = MPI_Wtime();
   if (myRank == 0)
      cout << "Sfile::read_sfile_topo, time to read topo file: " << time_end - time_start << " seconds." << endl;
   cout.flush();

#endif // if USE_HDF5
}

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_material(const std::string &filename, 
    EW &ew, MaterialSfile &model, vector<Sarray>& materials,
    vector<Sarray>& interfaces)
{
#ifdef USE_HDF5
   bool debug=false;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_material" << endl;

   // Timers
   double time_start = MPI_Wtime();
   // Open file
   hid_t mpiprop_id = H5Pcreate(H5P_DATASET_XFER);
   H5Pset_dxpl_mpio(mpiprop_id, H5FD_MPIO_INDEPENDENT);

   MPI_Comm comm = MPI_COMM_WORLD;
   MPI_Info info = MPI_INFO_NULL;
   hid_t prop_id = H5Pcreate(H5P_FILE_ACCESS);
   H5Pset_fapl_mpio(prop_id, comm, info);
   hid_t file_id = H5Fopen(const_cast<char *>(filename.c_str()),
      H5F_ACC_RDONLY, prop_id);
   if (file_id < 0)
   {
      cout << "Could not open hdf5 file: " << filename << endl;
      MPI_Abort(comm, file_id);
   }
   H5Pclose(prop_id);

   // Header - read all the metadata to the file
   if (debug && (myRank == 0))
      cout << "Reading hdf5 metadata for file: " << filename << endl;
   float h;
   vector<int> patch_nk;
   float lonlataz[3];
   read_sfile_header(file_id, mpiprop_id, h, lonlataz, patch_nk);
   ew.computeCartesianCoord(model.m_x0, model.m_y0, lonlataz[0], lonlataz[1]);
   int npatch = patch_nk.size();
   ASSERT(npatch > 0);
   model.m_hh.resize(npatch+1); // AP added +1
   for (int p=0; p <= npatch; ++p)
     model.m_hh[p] = h * pow(2,npatch-1-p);

   bool topoOnly = false;
   interfaces.resize(npatch+1);
   vector<Sarray*> intf(npatch+1,NULL);
   for (int p=0; p <= npatch; ++p)
      intf[p] = &interfaces[p];
   read_sfile_interface_group(file_id, mpiprop_id, topoOnly, intf);
                  
   // Create top/bottom interfaces for interpolation
   int nvars = (model.use_attenuation()) ? 5 : 3;
   float_sw4 bb[3][2];
   calculate_grid_boundingbox(ew, bb); // finest curv domain
   if (debug)
   {
     char msg[1000];
     sprintf(msg, "Rank %d: bounding box low [%0.2f,%0.2f,%0.2f], high [%0.2f,%0.2f,%0.2f]\n", myRank, bb[0][0], bb[1][0], bb[2][0], 
         bb[0][1], bb[1][1], bb[2][1]);
     cout << msg;
     cout.flush();
   }
   materials.resize(npatch);
   vector<vector<int> > bbijk(npatch); // For each patch, same layout as bb
   // int nghost = ew.getNumberOfGhostPoints();
   int nghost=0; // TODO - fill in ghost points or does MaterialSfile ?
   calculate_interpolation_patch(materials, nghost, bb, model.m_x0, model.m_y0, 
       h, nvars, patch_nk);

   if (debug)
   {
     char msg[1000];
     for (int g=0; g < ew.getNumberOfGrids(); ++g)
     {
        sprintf(msg, "Rank %d, grid %d: start [%d,%d,%d], end [%d,%d,%d]\n",
           myRank, g, ew.m_iStartInt[g], ew.m_jStartInt[g], ew.m_kStartInt[g], 
           ew.m_iEndInt[g], ew.m_jEndInt[g], ew.m_kEndInt[g]);
        cout << msg;
        cout.flush();
     }
   }

   // Read the material data into materials Sarrays
   // FIXME - DEBUG?
   read_sfile_material_group(file_id, mpiprop_id, nghost, nvars, materials);

   // TODO - anything else after we've read them? Min/max bounds?

   // Close file
   if (debug)
   {
     cout << "Rank " << myRank << " closing mpiprop..." << endl;
     cout.flush();
   }
   H5Pclose(mpiprop_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closing file..." << endl;
     cout.flush();
   }
   H5Fclose(file_id);
   if (debug)
   {
     cout << "Rank " << myRank << " closed file..." << endl;
     cout.flush();
   }

   // Timers
   double time_end = MPI_Wtime();
   if (myRank == 0)
      cout << "Sfile::read_sfile_material, time to read material file: " 
         << time_end - time_start << " seconds." << endl;
   cout.flush();

#endif // if USE_HDF5
}

//-----------------------------------------------------------------------
void SfileHDF5::write_sfile(const std::string &file,
  const std::string &path, bool use_attenuation, vector<Sarray>& material,
  vector<int>& ni, vector<int>& nj, vector<int>& nk,
  vector<float_sw4>& z0, vector<float_sw4>& hh, vector<float_sw4>& hv,
  double lon0, double lat0, double azim,
  vector<float_sw4>& mr_depth, int horizontalInterval)
{
#ifdef USE_HDF5
  bool debug=true;
  // Timers - get max time
  MPI_Barrier(MPI_COMM_WORLD);
  double time_start = MPI_Wtime();

  MPI_Comm comm = MPI_COMM_WORLD;
  MPI_Info info = MPI_INFO_NULL;
  int myRank;
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

  char msg[1000];
  if (myRank == 0)
    cout << "SfileHDF5::write_sfile - writing HDF5 sfile: " << file << endl;
  if (debug)
    cout << "Rank " << myRank << ", SfileHDF5::write_sfile" << endl;
  string filename = path + "/" + file;

  // Double-check that this horizontal interval for sampling works
  int hs = horizontalInterval;
  ASSERT((hs == 1) || (hs == 2) || (hs ==4));
  if (debug && (myRank==0))
    cout << "Subsampling at horizontal interval = " << hs << endl;

  // Locate patches/interfaces, figure out depth vs. grid-k index ranges
  int ngrids = material.size()-1; // z topo + materials in one array
  // skip z topo in first grid
  for (int g=1; g <= ngrids; ++g)
    if (debug)
      cout << "Input material grid " << g << " zmin=" << z0[g] << endl;
  vector<int> patch_nk;
  // Calculate how many points in each layer, last one is always Cart
  // Add the bottom-bottom
  float_sw4 zbot = z0[ngrids]+(nk[ngrids]-1)*hv[ngrids];
  mr_depth.push_back(zbot);
  int npatch = mr_depth.size();
  patch_nk.resize(npatch);
  for (int d=npatch-1; d >= 0; --d)
  {
    float_sw4 h = hv[1] * pow(2,d); 
    float dprev = (d == 0) ? 0 : mr_depth[d-1]; // top is depth 0
    int mk = floor((mr_depth[d] - dprev)/ h)+1;
    ASSERT(mk > 1); // at least 2 points
    if (d == npatch-1) // Make the bottom strictly Cartesian
      mr_depth[d-1] = mr_depth[d] - h*(float_sw4) (mk-1);
    patch_nk[npatch-1-d]=mk;
  }
  for (int p=0; p < npatch; ++p)
    if (debug)
      cout << "Patch p=" << p << ", above depth=" << mr_depth[npatch-1-p]
        << " has nk=" << patch_nk[p] << endl;

  // Open file
  hid_t mpiprop_id = H5Pcreate(H5P_DATASET_XFER);
  H5Pset_dxpl_mpio(mpiprop_id, H5FD_MPIO_INDEPENDENT);

  hid_t prop_id = H5Pcreate(H5P_FILE_ACCESS);
  H5Pset_fapl_mpio(prop_id, comm, info);
  hid_t file_id = H5Fcreate(const_cast<char *>(filename.c_str()),
      H5F_ACC_TRUNC, H5P_DEFAULT, prop_id);
  if (file_id < 0)
  {
    cout << "Could not open hdf5 file: " << filename << endl;
    MPI_Abort(comm, file_id);
  }
  H5Pclose(prop_id);

  // Add all the header metadata to the file
  if (debug && (myRank == 0))
    cout << "Writing hdf5 metadata for file: " << filename << endl;

  // Horizontal grid spacing - h constant in horizontal, double (avoids roundoff for large nx), assume 2x coarsening with grid interfaces (watch out for mod 2 coarsening), make sure it’s self-consistent
  float h = hh[1] * hs * (float) pow(2,npatch-1); // top grid coarsened
  float lonlataz[3] = {lon0, lat0, azim};
  // Patches are in bottom-up order, patch_breaks interfaces are top-down
  //   cout << "before header write" << endl;
  write_sfile_header(file_id, mpiprop_id, h, lonlataz, patch_nk);
  //   cout << "after header write" << endl;
  vector<float*> z_bot, z_top;
  write_sfile_interfaces(file_id, mpiprop_id, ni[0], nj[0], 
      material[0], patch_nk, mr_depth, z_bot, z_top);
  //   cout << "after interfaces write" << endl;
  ASSERT((z_bot.size() == npatch) && (z_top.size() == npatch));

  write_sfile_materials2(file_id, mpiprop_id, material, z0, hv, ni, nj, nk,
      patch_nk, z_bot, z_top);
  //   cout << "after materials write" << endl;
  for (int i=0; i<z_bot.size(); ++i)
  {
    delete[] z_bot[i];
    delete[] z_top[i];
  }

  // Close file
  if (debug)
  {
    cout << "Rank " << myRank << " closing mpiprop..." << endl;
    cout.flush();
  }
  H5Pclose(mpiprop_id);
  if (debug)
  {
    cout << "Rank " << myRank << " closing file..." << endl;
    cout.flush();
  }
  H5Fclose(file_id);
  if (debug)
  {
    cout << "Rank " << myRank << " closed file..." << endl;
    cout.flush();
  }

  // Timers
  MPI_Barrier(MPI_COMM_WORLD);
  double time_end = MPI_Wtime();
  if (myRank == 0)
    cout << "SfileHDF5::write_sfile, time to write material file: " 
      << time_end - time_start << " seconds." << endl;
  cout.flush();

#endif // if USE_HDF5
}

#if 0
//-----------------------------------------------------------------------
void SfileHDF5::calculate_patches(vector<Sarray>& material,
    vector<float_sw4>& z0, vector<float_sw4>& hh, vector<float_sw4>& hv,
    vector<int>& nk, vector<float_sw4>& mr_depth, int hs, 
    vector<vector<sfile_breaks> >& patch_breaks, vector<int>& patch_nk)
{
  const bool debug=true;
  float_sw4 tol = 1e-5;
  int ngrids = material.size()-1; // 0 is topo, so data in 1:ngrids
  vector<sfile_breaks> brks;
  float_sw4 gzmax = z0[ngrids] + hv[ngrids]*(nk[ngrids]-1);
  for (int d=0; d < mr_depth.size(); ++d)
    if (mr_depth[d] > (gzmax-tol)) // Below the bottom of the domain, truncate
      mr_depth.resize(d+1);
  mr_depth.push_back(gzmax); // Add the bottom

  int npatch = mr_depth.size();
  patch_breaks.resize(npatch);
  // TODO - pseudocode:
  // 0. For each patch
  // 1. Calculate the grid each depth is in
  // 1a. NOTE: have to agree across all ranks?
  // 2. Figure out the hs for each grid overlapping with this patch

  sfile_breaks b = {.p = -1, .g = 1, .kb = 1, .ke = -1};
  for (int d=0; d < npatch; ++d)
  {
    b.p = npatch-1-d; // patch above this depth
    float_sw4 depth = mr_depth[d];
    // Loop down through the grids to find the break, appending as we go
    for (int g=1; g <=ngrids; ++g)
    {
      b.g = g;
      // Sampling factor gets smaller as we coarsen patches
      int sfactor = (npatch-1-b.p)+(b.g-1);
      ASSERT(sfactor >= 0);
      b.hs = pow(2,sfactor)*hs;
      b.vs = pow(2,sfactor);
      int gkmax = nk[g];
      float_sw4 h = hv[g]; // vertical grid spacing
      // Topo grid
      float_sw4 zmin, zmax;
      if (g==1)
      {
        zmin = 0; // depth from top
        zmax = z0[g+1]; // next cart grid
      }
      else // Cartesian grid
      {
        zmin = z0[g];
        zmax = zmin + (gkmax-1)*h;
      }
      int mk = floor(tol + (depth - zmin)/h)+1; // approximate k re: h
      // We treat top curv + next cart grid as one grid
      if (depth < (zmax+tol))
      {  
        // Where is the break?
        if (mk <= gkmax)
        {  // Before the end of curv grid
          b.ke = mk;
          brks.push_back(b);
          b.kb = mk;
          b.ke = -1;
          if (mk == gkmax) // At the end, go to the next grid
          {
            b.g++;
            b.kb = 1;
          }
          break; // go to next depth entry
        }
      }
      else // depth > (zmax+tol)
      {  // past end of this grid, continue
        b.ke = gkmax;
        brks.push_back(b);
        if (b.g < ngrids) // Only if there is another grid to search
        {
          b.kb = 1;
          b.ke = -1;
        }
        continue; // keep looking next grid
      }
    }
  }

  // Go back through and bin by patch
  for (int b=0; b < brks.size(); ++b)
  {
    ASSERT((brks[b].hs > 0) && (brks[b].vs > 0));
    patch_breaks[brks[b].p].push_back(brks[b]);
  }

  npatch = patch_breaks.size();
  patch_nk.resize(npatch);
  for (int p=0; p<npatch; ++p)
  {
    float nk = 0;
    vector<sfile_breaks>& pbrk = patch_breaks[p];
    for (int b=0; b < pbrk.size(); ++b) // Add number of points
    {
      int gk = pbrk[b].ke-pbrk[b].kb; 
      float k = (gk+1)/pbrk[b].vs;
      nk += k; // rough number of vs
      if (b > 0) --nk; // Remove 1 point for overlap between grids
      patch_nk[p] = floor(nk);
      if (debug)
      {
        cout << "Patch " << pbrk[b].p << " above depth " 
          << mr_depth[npatch-1-pbrk[b].p] << ", accum nk=" << patch_nk[p]
          << ", k=" << k << ", in grid " << pbrk[b].g
          << ", index range (" << pbrk[b].kb << ", " << pbrk[b].ke 
          << "), hs = " << pbrk[b].hs << ", vs= " << pbrk[b].vs << endl;
        cout.flush();
      }
      // ASSERT(gk >= pbrk[b].vs); // Not necessary with interpolation?
      ASSERT((gk+1) >= 2); // At least 2 points
    }
  }
}
#endif // #if 0

//-----------------------------------------------------------------------
#ifdef USE_HDF5
void SfileHDF5::write_sfile_header(hid_t file_id, hid_t mpiprop_id, 
    const float& h_coarse, const float (&lonlataz)[3], vector<int>& patch_nk)
{
   //   TODO:
   //   Filetype - string, to make sure it’s this type of file, “SW4 Matfile”
   //   Filetype version - string, to make sure we know how to read it, “v1”
   //   Description metadata - string (ex: “Generated by SW4 from berkeley.rfile at …”)
   //   Proj4 string (see rfile spec)
  hsize_t dim = 1;
  hid_t dataspace_id = H5Screate_simple(1, &dim, NULL);
  hid_t dataset_id = H5Dcreate2(file_id, "Coarsest horizontal grid spacing",
      H5T_IEEE_F32LE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  herr_t ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL, 
      mpiprop_id, &h_coarse);
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);

  // Longitude, latitude, azimuth
  dim = 3;
  dataspace_id = H5Screate_simple(1, &dim, NULL);
  dataset_id = H5Dcreate2(file_id, "Origin longitude, latitude, azimuth",
      H5T_IEEE_F32LE, dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL,
                  mpiprop_id, lonlataz);
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);

  //   Ngrids - int, number of 3D grids in the file
  dim = 1;
  int npatch = patch_nk.size();
  dataspace_id = H5Screate_simple(1, &dim, NULL);
  dataset_id = H5Dcreate2(file_id, "ngrids", H5T_STD_I32LE,
      dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  ierr = H5Dwrite(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL,
      mpiprop_id, &npatch);
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);

  //   Number of grid points in vertical for each grid (needed for topo command)
  dim = npatch;
  dataspace_id = H5Screate_simple(1, &dim, NULL);
  dataset_id = H5Dcreate2(file_id, "grid nz", H5T_STD_I32LE,
      dataspace_id, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
  ierr = H5Dwrite(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL, 
      mpiprop_id, patch_nk.data());
  ierr = H5Dclose(dataset_id);
  ierr = H5Sclose(dataspace_id);
}

//-----------------------------------------------------------------------
void SfileHDF5::get_patch_dims_2( EW& ew, int g, int hs, int& ibeg, int& iend, int& jbeg, int& jend )
{
   int ib=ew.m_iStartInt[g];
   int ie=ew.m_iEndInt[g];
   int jb=ew.m_jStartInt[g];
   int je=ew.m_jEndInt[g];
   if( (ib-1) % hs == 0 )
      ibeg = (ib-1)/hs;
   else
      ibeg = (ib-1)/hs+1;
   if( (jb-1) % hs == 0 )
      jbeg = (jb-1)/hs;
   else
      jbeg = (jb-1)/hs+1;
   iend = (ie-1)/hs;
   jend = (je-1)/hs;
}
//-----------------------------------------------------------------------
void SfileHDF5::get_patch_dims( sfile_breaks brk, int& ibeg, int& iend, int& jbeg, int& jend )
{
   if( (brk.ib-1) % brk.hs == 0 )
      ibeg = (brk.ib-1)/brk.hs;
   else
      ibeg = (brk.ib-1)/brk.hs+1;
   if( (brk.jb-1) % brk.hs == 0 )
      jbeg = (brk.jb-1)/brk.hs;
   else
      jbeg = (brk.jb-1)/brk.hs+1;
   iend = (brk.ie-1)/brk.hs;
   jend = (brk.je-1)/brk.hs;
}

//-----------------------------------------------------------------------
void smooth_z_interface(float *data, int maxIter, int imin, int imax, int jmin, int jmax)
{
    float_sw4 rf=0.2; // rf<0.25 for stability
    int iter;
    int isize = imax - imin + 1, jsize = jmax - jmin + 1;
    int size = isize * jsize;
    float *tmp  = new float[size];

    // Laplacian filter
    for (iter=0; iter < maxIter; iter++)
    {
        #pragma omp parallel for
        for (int i = imin+1; i <= imax-1; ++i) 
        {
            for (int j = jmin+1; j <= jmax-1; ++j)
            {
                tmp[i + j*isize] = data[i + j*isize] + rf*(data[i+1 + j*isize ] + 
                                   data[i-1 + j*isize] + data[i + (j+1)*isize] + 
                                   data[i + (j-1)*isize] - 4.*data[i + j*isize]);
            }
        }

        // Neumann boundary conditions
        #pragma omp parallel for
        for (int j = jmin+1; j <= jmax-1; ++j)
        {
            int i = imin;
            tmp[i + j*isize] = tmp[i+1 + j*isize];
            i = imax;
            tmp[i + j*isize] = tmp[i-1 + j*isize];
        }

        #pragma omp parallel for
        for (int i = imin+1; i <= imax-1; ++i)
        {
            int j = jmin;
            tmp[i + j*isize] = tmp[i + (j+1)*isize];
            j = jmax;
            tmp[i + j*isize] = tmp[i + (j-1)*isize];
        }
        // Corners
        int i = imin;
        int j = jmin;
        tmp[i + j*isize] = tmp[i+1 + (j+1)*isize];

        i = imax;
        j = jmin;
        tmp[i + j*isize] = tmp[i-1 + (j+1)*isize];

        i = imin;
        j = jmax;
        tmp[i + j*isize] = tmp[i+1 + (j-1)*isize];

        i = imax;
        j = jmax;
        tmp[i + j*isize] = tmp[i-1 + (j-1)*isize];

        /* communicate_array_2d_ext( tmp ); */

        // update solution
        memcpy(data, tmp, sizeof(float)*size);
    }// end for iter
}


//-----------------------------------------------------------------------
void SfileHDF5::interp_interface(float* z_top, float* z_bot, 
    int fibeg, int fiend, int fjbeg, int fjend)
{
  // z_bot has dims (fibeg:fiend,fjbeg:fjend)
  // assume hs=2 coarser for z_top (from p-1)
  // set coarse points to be the same
  // set in-between points to be avg of coarse ones
  assert(((fiend-fibeg)%2)==0); // make sure we can coarsen by 2
  int sizei = (fiend-fibeg)+1;
  int sizeci = (fiend-fibeg)/2 +1;
  int cibeg = fibeg/2;
  int ciend = fiend/2;
  int cjbeg = fjbeg/2;
  int cjend = fjend/2;
  for (int cj=cjbeg; cj <= cjend; ++cj)
  for (int ci=cibeg; ci <= ciend; ++ci)
  {
    int cix = ci-cibeg+sizeci*(cj-cjbeg);
    // corresponding fine grid index
    int i=2*ci;
    int j=2*cj;
    int ix = i+sizei*j;

    // Copy node values
    z_bot[ix] = z_top[cix];

    // Avg coarse points to the other 3 nearby fine points (1,0), (0,1), (1,1)
    if (ci < ciend)
      z_bot[ix+1] = .5*(z_top[cix] + z_top[cix+1]);
    if (cj < cjend)
      z_bot[ix+sizei] = .5*(z_top[cix] + z_top[cix+sizeci]);
    if ((ci < ciend) && (cj < cjend))
      z_bot[ix+1+sizei] = .25*(z_top[cix] + z_top[cix+1]
          + z_top[cix+sizeci] + z_top[cix+1+sizeci]);
  }
}


//-----------------------------------------------------------------------
void SfileHDF5::write_sfile_interfaces(hid_t file_id, hid_t mpiprop_id, 
    int nitop, int njtop,
    Sarray& z_topo, vector<int>& patch_nk, vector<float_sw4>& mr_depth,
    vector<float*>& z_bot, vector<float*>& z_top)
{
  const bool debug=true;
  MPI_Comm comm = MPI_COMM_WORLD;
  int myRank;
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

  char msg[1000];
  hsize_t dim = 1;
  herr_t ierr;
  hid_t dataspace_id;
  hid_t dataset_id;

  // Topo/interface section
  //     Even for cartesian, store them all, including the bottom
  //     For each grid, its lower interface is at the resolution of the lower grid (avoids interpolation, is a saw-tooth like interpolation)

  // Create the z_interface group
  hid_t group_id;
  char group_name[] = "Z_interfaces";
  group_id = H5Gcreate(file_id, group_name, H5P_DEFAULT,
      H5P_DEFAULT, H5P_DEFAULT);
  // Write 2D patches just for topo “interfaces” - elevation for top and any internal grid boundaries, as well as the bottom.
  int npatch = patch_nk.size();
  z_bot.resize(npatch, NULL);
  z_top.resize(npatch, NULL);
  if (debug)
  {
    sprintf(msg, "Rank %d, z_topo indices [%d:%d,%d:%d] in [1:%d,1:%d]\n", 
        myRank, z_topo.m_ib, z_topo.m_ie, z_topo.m_jb, z_topo.m_je, 
        nitop, njtop);
    cout << msg;
    cout.flush();
  }

  for (int p = 0; p < npatch; ++p)
  {
    for (int b=0; b <= 1; ++b) // loop over bottom/top
    {
      int hs = pow(2,npatch-p-1); // increase in grid spacing from top
      ASSERT(!((nitop-1) % hs)); // assume divisible by hs
      ASSERT(!((njtop-1) % hs));
      int cni = (nitop-1)/hs + 1;
      int cnj = (njtop-1)/hs + 1;

      // Get ranges for coarse 0-based indices
      int cibeg = (z_topo.m_ib-1)/hs + (((z_topo.m_ib-1) % hs) ? 1 : 0);
      int ciend = (z_topo.m_ie-1)/hs;
      int cjbeg = (z_topo.m_jb-1)/hs + (((z_topo.m_jb-1) % hs) ? 1 : 0);
      int cjend = (z_topo.m_je-1)/hs;
      string if_name = (b==0) ? "z_bot" : "z_top";
      if (debug)
      {
        sprintf(msg, "Rank %d, patch %d %s, topo indices [%d:%d,%d:%d] in [0:%d,0:%d]\n", 
            myRank, p, if_name.c_str(), 
            cibeg, ciend, cjbeg, cjend, cni-1, cnj-1);
        cout << msg;
        cout.flush();
      }

      // Z interface values
      hsize_t z_dims = 2;
      hsize_t slice_dims[2], global_dims[2], chunk_dims[2];
      // This processor's horizontal window, interior points

      slice_dims[0] = ciend-cibeg+1;
      slice_dims[1] = cjend-cjbeg+1;
      global_dims[0] = cni;
      global_dims[1] = cnj;

      hsize_t start[3];
      start[0] = cibeg;
      start[1] = cjbeg;
      start[2] = 0;

      // Allocate our tmp arrays on first pass
      size_t npts = (size_t)(slice_dims[0] * slice_dims[1]);
      if (b==0) // allocate both on first pass
      {
        z_bot[p] = new float[npts];
        z_top[p] = new float[npts];
      }

      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      // Create dataset for z field
      hid_t dataspace_id = H5Screate_simple(z_dims, global_dims, NULL);
      char buff[100];
      sprintf(buff, "%s_%d", if_name.c_str(), p);
      dataset_id = H5Dcreate2(group_id, buff, H5T_IEEE_F32LE,
          dataspace_id, H5P_DEFAULT, prop_id, H5P_DEFAULT);
      if (dataset_id < 0)
      {
        cout << "SfileHDF5::write_sfile_interfaces: "
          << "Could not create dataset" << buff << "!" << endl;
        MPI_Abort(comm, file_id);
      }
      hid_t space_id = H5Screate(H5S_SCALAR);
      sprintf(buff, "%s_id", if_name.c_str());
      hid_t attr_id = H5Acreate(dataset_id, buff, H5T_STD_I32LE,
          space_id, H5P_DEFAULT, H5P_DEFAULT);
      H5Awrite(attr_id, H5T_STD_I32LE, &p);
      ierr = H5Aclose(attr_id);
      ierr = H5Sclose(space_id);

      // Write the data, if topo, or generate for cart
      if (debug)
      {
        sprintf(msg, "Rank %d, selecting patch %d %s hyperslab = [%d %d], size [%d,%d] in [0:%d,0:%d] \n",
            myRank, p, if_name.c_str(), (int)start[0], (int)start[1],
            (int)slice_dims[0], (int)slice_dims[1],
            (int)global_dims[0]-1, (int)global_dims[1]-1);
        cout << msg;
        cout.flush();
      }
      hid_t window_id = H5Screate_simple(z_dims, slice_dims, NULL);
      ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, NULL,
          slice_dims, NULL);
      if (ierr < 0)
      {
        cout << "Error from z H5Sselect_hyperslab" << endl;
        MPI_Abort(comm,ierr);
      }
      if (debug)
      {
        char msg[1000];
        sprintf(msg, "Writing z array Rank %d\n", myRank);
        cout << msg;
        cout.flush();
      }
      bool topbot = (p==0 && b==0) || (p==npatch-1 && b==1);
      if (topbot || !(b==0)) // not an interior z_bot
        patch_interface(z_bot, z_top, slice_dims, p, b,
            patch_nk, mr_depth, hs, cibeg, cjbeg, z_topo);
      else // interior z_bot, interp from z_top[p-1]
        interp_interface(z_top[p-1], z_bot[p], cibeg, ciend, cjbeg, cjend);

      // Smooth the middle z_top's only
      float* z_vals = (b==0) ? z_bot[p] : z_top[p];
      if (!topbot && !(b==0))
      {
        int niter = 10;
        smooth_z_interface(z_vals, niter, 0, slice_dims[0]-1, 0, slice_dims[1]-1);
      }

      ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, window_id, dataspace_id,
          mpiprop_id, z_vals);
      if (ierr < 0)
      {
        cout << "Error from SfileHDF5 topo H5Dwrite " << endl;
        MPI_Abort(comm,ierr);
      }
      ierr = H5Sclose(window_id);
      ierr = H5Dclose(dataset_id);
      ierr = H5Sclose(dataspace_id);
      ierr = H5Pclose(prop_id);
    }
  }
  ierr = H5Gclose(group_id); // Z_interface group
}


//-----------------------------------------------------------------------
void SfileHDF5::write_sfile_materials(hid_t file_id, hid_t mpiprop_id, EW& ew, 
    MaterialRfile &model, vector<vector<sfile_breaks> >& patch_breaks,
    vector<int>& patch_nk, vector<float*>& z_bot, vector<float*>& z_top)
{
   const bool debug=false;
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

   char msg[1000];
   herr_t ierr;

   int nvars = (model.use_attenuation()) ? 5 : 3;
   int npatch = patch_breaks.size();
   int ngrids = ew.mNumberOfGrids;

   // Write the material data for each grid
   hid_t group_id = H5Gcreate(file_id, "Material_model", H5P_DEFAULT, 
       H5P_DEFAULT, H5P_DEFAULT);
   // Material output on each patch
   for (int p=0; p < npatch; p++)
   {
      // NB: these are stored in order of g high to g low
      vector<sfile_breaks>& brks = patch_breaks[p];
      int nk = patch_nk[p];

      // Write datasets from all the grids this patch intersects
      hsize_t dims = 3;
      hsize_t slice_dims[3], global_dims[3];
      if (debug)
      {
         char msg[1000];
         sprintf(msg, "Writing arrays for patch %d, rank %d\n", p, myRank);
         cout << msg;
         cout.flush();
      }
      // For each patch, add the material from sw4's grids
      char buff[100];
      sprintf(buff, "Material_model/grid_%d", p);
      hid_t grid_id = H5Gcreate(file_id, buff, H5P_DEFAULT, 
         H5P_DEFAULT, H5P_DEFAULT);
      // add grid id attribute to the grid group
      hid_t space_id = H5Screate(H5S_SCALAR);
      hid_t attr_id = H5Acreate(grid_id, "grid_id", H5T_STD_I32LE, 
          space_id, H5P_DEFAULT, H5P_DEFAULT);
      H5Awrite(attr_id, H5T_STD_I32LE, &p);
      ierr = H5Aclose(attr_id);
      ierr = H5Sclose(space_id);

      int g = brks[0].g; // Should be the first grid, thus the correct rez/pts
      // This processor's horizontal window, interior points only
      int hs = brks[0].hs;

      int ibeg, iend, jbeg, jend;
      //      get_patch_dims( brks[0], ibeg, iend, jbeg, jend );
      get_patch_dims_2( ew, g, hs, ibeg, iend, jbeg, jend );

      slice_dims[0] = iend-ibeg+1;
      slice_dims[1] = jend-jbeg+1;

      //      slice_dims[0] = ((ew.m_iEndInt[g]-1) - (ew.m_iStartInt[g]-1))/hs + 1;
      //      slice_dims[1] = ((ew.m_jEndInt[g]-1) - (ew.m_jStartInt[g]-1))/hs + 1;

      slice_dims[2] = nk;
      hsize_t start[3];
      //      start[0] = hsib;
      //      start[1] = hsjb;
      start[0] = ibeg;
      start[1] = jbeg;
      start[2] = 0; // write all z values

      global_dims[0] = (ew.m_global_nx[g]-1)/hs + 1;
      global_dims[1] = (ew.m_global_ny[g]-1)/hs + 1;

      //      global_dims[0] = hsnx;
      //      global_dims[1] = hsny;
      global_dims[2] = nk;

      const char *field[] = {"Rho", "Cp", "Cs", "Qp", "Qs"};
      int nvars = (model.use_attenuation()) ? 5 : 3;

      // Modify dataset creation properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      // herr_t ierr = H5Pset_chunk(prop_id, dims, slice_dims);
      // Create the variables for this grid
      for (int c=0; c < nvars; c++)
      {
        hid_t dataspace_id = H5Screate_simple(dims, global_dims, NULL);
        hid_t dataset_id = H5Dcreate2(grid_id, field[c], H5T_IEEE_F32LE,
          dataspace_id, H5P_DEFAULT, prop_id, H5P_DEFAULT);
        ierr = H5Sclose(dataspace_id);
        ierr = H5Dclose(dataset_id);
      }

      // Create temp arrays for this patch
      size_t ncols = (size_t)(slice_dims[0] * slice_dims[1]);
      size_t npts = (size_t)(slice_dims[0]*slice_dims[1]*slice_dims[2]);
      vector<float*> h5_array(nvars);
      for (int v=0; v < nvars; ++v)
      {
        h5_array[v] = new float[npts];
#pragma omp parallel for
        for (int ix=0; ix < npts; ++ix)
          h5_array[v] = 0; // Initialize with invalid
      }

      // int koffset = 0;
      // Do the interpolation
      for (int b=0; b < brks.size(); b++)
      {
        sfile_breaks& brk = brks[b];
        int g = brk.g;
        // TODO - is this the right window?
        brk.ib = ew.m_iStartInt[g];
        brk.ie = ew.m_iEndInt[g];
        brk.jb = ew.m_jStartInt[g];
        brk.je = ew.m_jEndInt[g];
        // Interopolate all variables
	//	cout << myRank << "brks="<< b << " p="<< p << " g="<< g << endl;
        Sarray* z = (ew.m_topography_exists && (g==ngrids-1)) ? &(ew.mZ) : NULL;
        material_interpolate_2(h5_array, z_bot[p], z_top[p], 
            slice_dims, brk, z, ew.m_zmin[g], ew.mGridSize[g], npatch, ngrids,
            ew.mRho[g], ew.mMu[g], ew.mLambda[g], ew.mQp[g], ew.mQs[g]);
        // Don't need this? koffset += (slice_dims[2]-1); // For overlap
	//	cout << myRank << " Exit brks="<< b << " p="<< p << " g="<< g << endl;
      }

      // Calculate global min/max with MPI reduction
      float var_min[npatch][nvars];
      float var_max[npatch][nvars];
      float omp_min[nvars], omp_max[nvars];
      for (int v=0; v < nvars; ++v)
      {
        float omp_min = 1e8;
        float omp_max = -1;
#pragma omp parallel for reduction(max:omp_max) reduction(min:omp_min)
        for (int ix=0; ix < npts; ++ix)
        {
            omp_min = min(omp_min, h5_array[v][ix]);
            omp_max = max(omp_max, h5_array[v][ix]);
        }
        var_min[p][v] = omp_min;
        var_max[p][v] = omp_max;
      }
      float var_min_glb[nvars], var_max_glb[nvars];
      MPI_Reduce(var_min[p], var_min_glb, nvars, MPI_FLOAT, MPI_MIN, 0, MPI_COMM_WORLD );
      MPI_Reduce(var_max[p], var_max_glb, nvars, MPI_FLOAT, MPI_MAX, 0, MPI_COMM_WORLD );
      for (int v=0; v < nvars; ++v)
      {
        var_min[p][v] = var_min_glb[v];
        var_max[p][v] = var_max_glb[v];
      }

      // Do the hdf5 write in chunks
      // TODO - need to chunk!
      // chunk_dims[0] = 10;
      // chunk_dims[1] = 10;
      // chunk_dims[2] = 10;
      for (int v=0; v < nvars; v++)
      {
      if (myRank == 0)
        cout << "Material sfile patch " << p 
          << " min " << field[v] << " =" << var_min[p][v]
          << ", max " << field[v] << " =" << var_max[p][v] << endl;

        hid_t dataset_id = H5Dopen2(grid_id, field[v], H5P_DEFAULT);
        hid_t dataspace_id = H5Dget_space(dataset_id);
        hid_t window_id = H5Screate_simple(dims, slice_dims, NULL);
        ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, 
            NULL, slice_dims, NULL);
        if (debug)
        {
           sprintf(msg, "Rank %d selecting %s for hyperslab = [%d %d %d], size [%d,%d,%d] in [%d,%d,%d] \n",
              myRank, field[v], (int) start[0], (int) start[1], (int) start[2],
              (int) slice_dims[0], (int) slice_dims[1], (int) slice_dims[2],
              (int) global_dims[0], (int) global_dims[1], (int) global_dims[2]);
           cout << msg;
           cout.flush();
        }
        // Write this variable
        ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, window_id, 
             dataspace_id, mpiprop_id, h5_array[v]);
        if (ierr < 0)
        {
          cout << "Error from SfileHDF5 component H5Dwrite " << endl;
          MPI_Abort(comm,ierr);
        }
        ierr = H5Sclose(dataspace_id);
        ierr = H5Dclose(dataset_id);
        if (debug)
        {
          char msg[1000];
          sprintf(msg, "Wrote %s array, patch %d, rank %d\n", 
              field[v], p, myRank);
          cout << msg;
          cout.flush();
        }
      } // for v
      ierr = H5Pclose(prop_id);
      ierr = H5Gclose(grid_id); // Material_model_grid_XX group

      for (int v=0; v < nvars; v++)
      {
        delete[] h5_array[v];
        h5_array[v] = NULL;
      }
   }
   if (debug)
      cout << "Rank " << myRank << " closing group..." << endl;
   cout.flush();
   ierr = H5Gclose(group_id); // Material_model group
}


//-----------------------------------------------------------------------
void SfileHDF5::write_sfile_materials2(hid_t file_id, hid_t mpiprop_id,
    vector<Sarray>& material, vector<float_sw4>& z0, vector<float_sw4>& hh,
    vector<int>& ni, vector<int>& nj, vector<int>& nk,
    vector<int>& patch_nk, vector<float*>& z_bot, vector<float*>& z_top)
{
   const bool debug=false;
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

   char msg[1000];
   herr_t ierr;

   int nrpatch = material.size()-1; // 0 index is just topo, ignore
   int nvars = 5;
   int npatch = patch_nk.size();

   // Write the material data for each grid
   hid_t group_id = H5Gcreate(file_id, "Material_model", H5P_DEFAULT, 
       H5P_DEFAULT, H5P_DEFAULT);
   // Material output on each patch
   for (int p=0; p < npatch; p++)
   {
      // NB: these are stored in order of g high to g low
      int nk = patch_nk[p];

      // Write datasets from all the grids this patch intersects
      hsize_t dims = 3;
      hsize_t slice_dims[3], global_dims[3];
      if (debug)
      {
         char msg[1000];
         sprintf(msg, "Writing arrays for patch %d, rank %d\n", p, myRank);
         cout << msg;
         cout.flush();
      }
      // For each patch, add the material from sw4's grids
      char buff[100];
      sprintf(buff, "Material_model/grid_%d", p);
      hid_t grid_id = H5Gcreate(file_id, buff, H5P_DEFAULT, 
         H5P_DEFAULT, H5P_DEFAULT);
      // add grid id attribute to the grid group
      hid_t space_id = H5Screate(H5S_SCALAR);
      hid_t attr_id = H5Acreate(grid_id, "grid_id", H5T_STD_I32LE, 
          space_id, H5P_DEFAULT, H5P_DEFAULT);
      H5Awrite(attr_id, H5T_STD_I32LE, &p);
      ierr = H5Aclose(attr_id);
      ierr = H5Sclose(space_id);

#if 0
      int g = brks[0].g; // Should be the first grid, thus the correct rez/pts
      // This processor's horizontal window, interior points only
      int hs = brks[0].hs;

      //      get_patch_dims( brks[0], ibeg, iend, jbeg, jend );
      get_patch_dims_2( ew, g, hs, ibeg, iend, jbeg, jend );
#endif
      /*
      int ibeg = (z_topo.m_ib-1)/hs + (((z_topo.m_ib-1) % hs) ? 1 : 0);
      int iend = (z_topo.m_ie-1)/hs;
      int jbeg = (z_topo.m_jb-1)/hs + (((z_topo.m_jb-1) % hs) ? 1 : 0);
      int jend = (z_topo.m_je-1)/hs;
      slice_dims[0] = iend-ibeg+1;
      slice_dims[1] = jend-jbeg+1;
      slice_dims[2] = nk;
      */

      hsize_t start[3];
      start[0] = 0;
      start[1] = 0;
      start[2] = 0; // write all z values

      slice_dims[0] = ni[p+1];
      slice_dims[1] = nj[p+1];
      slice_dims[2] = nk;

      global_dims[0] = ni[p+1];
      global_dims[1] = nj[p+1];
      global_dims[2] = nk;

      const char *field[] = {"Rho", "Cp", "Cs", "Qp", "Qs"};
      int nvars = 5; // use attenuation variables

      // Modify dataset creation properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      // herr_t ierr = H5Pset_chunk(prop_id, dims, slice_dims);
      // Create the variables for this grid
      for (int c=0; c < nvars; c++)
      {
        hid_t dataspace_id = H5Screate_simple(dims, global_dims, NULL);
        hid_t dataset_id = H5Dcreate2(grid_id, field[c], H5T_IEEE_F32LE,
          dataspace_id, H5P_DEFAULT, prop_id, H5P_DEFAULT);
        ierr = H5Sclose(dataspace_id);
        ierr = H5Dclose(dataset_id);
      }

      // Create temp arrays for this patch
      size_t ncols = (size_t)(slice_dims[0] * slice_dims[1]);
      size_t npts = (size_t)(slice_dims[0]*slice_dims[1]*slice_dims[2]);
      vector<float*> h5_array(nvars);
      for (int v=0; v < nvars; ++v)
      {
        h5_array[v] = new float[npts];
#pragma omp parallel for
        for (int ix=0; ix < npts; ++ix)
          h5_array[v] = 0; // Initialize with invalid
      }

#if 0
      // int koffset = 0;
      // Do the interpolation
      for (int b=0; b < brks.size(); b++)
      {
        sfile_breaks& brk = brks[b];
        int g = brk.g;
        // TODO - is this the right window?
        brk.ib = ew.m_iStartInt[g];
        brk.ie = ew.m_iEndInt[g];
        brk.jb = ew.m_jStartInt[g];
        brk.je = ew.m_jEndInt[g];
        // Interopolate all variables
	//	cout << myRank << "brks="<< b << " p="<< p << " g="<< g << endl;
        Sarray* z = (ew.m_topography_exists && (g==ngrids-1)) ? &(ew.mZ) : NULL;
        material_interpolate_2(h5_array, z_bot[p], z_top[p], 
            slice_dims, brk, z, ew.m_zmin[g], ew.mGridSize[g], npatch, ngrids,
            ew.mRho[g], ew.mMu[g], ew.mLambda[g], ew.mQp[g], ew.mQs[g]);
        // Don't need this? koffset += (slice_dims[2]-1); // For overlap
	//	cout << myRank << " Exit brks="<< b << " p="<< p << " g="<< g << endl;
      }
      // Calculate global min/max with MPI reduction
      float var_min[npatch][nvars];
      float var_max[npatch][nvars];
      float omp_min[nvars], omp_max[nvars];
      for (int v=0; v < nvars; ++v)
      {
        float omp_min = 1e8;
        float omp_max = -1;
#pragma omp parallel for reduction(max:omp_max) reduction(min:omp_min)
        for (int ix=0; ix < npts; ++ix)
        {
            omp_min = min(omp_min, h5_array[v][ix]);
            omp_max = max(omp_max, h5_array[v][ix]);
        }
        var_min[p][v] = omp_min;
        var_max[p][v] = omp_max;
      }
      float var_min_glb[nvars], var_max_glb[nvars];
      MPI_Reduce(var_min[p], var_min_glb, nvars, MPI_FLOAT, MPI_MIN, 0, MPI_COMM_WORLD );
      MPI_Reduce(var_max[p], var_max_glb, nvars, MPI_FLOAT, MPI_MAX, 0, MPI_COMM_WORLD );
      for (int v=0; v < nvars; ++v)
      {
        var_min[p][v] = var_min_glb[v];
        var_max[p][v] = var_max_glb[v];
      }
#endif

      // Do the hdf5 write in chunks
      // TODO - need to chunk!
      // chunk_dims[0] = 10;
      // chunk_dims[1] = 10;
      // chunk_dims[2] = 10;
      for (int v=0; v < nvars; v++)
      {
        /*
        if (myRank == 0)
          cout << "Material sfile patch " << p 
            << " min " << field[v] << " =" << var_min[p][v]
            << ", max " << field[v] << " =" << var_max[p][v] << endl;
        */

        hid_t dataset_id = H5Dopen2(grid_id, field[v], H5P_DEFAULT);
        hid_t dataspace_id = H5Dget_space(dataset_id);
        hid_t window_id = H5Screate_simple(dims, slice_dims, NULL);
        ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, 
            NULL, slice_dims, NULL);
        if (debug)
        {
           sprintf(msg, "Rank %d selecting %s for hyperslab = [%d %d %d], size [%d,%d,%d] in [%d,%d,%d] \n",
              myRank, field[v], (int) start[0], (int) start[1], (int) start[2],
              (int) slice_dims[0], (int) slice_dims[1], (int) slice_dims[2],
              (int) global_dims[0], (int) global_dims[1], (int) global_dims[2]);
           cout << msg;
           cout.flush();
        }
        // Write this variable
        /*
        ierr = H5Dwrite(dataset_id, H5T_IEEE_F32LE, window_id, 
             dataspace_id, mpiprop_id, h5_array[v]);
        if (ierr < 0)
        {
          cout << "Error from SfileHDF5 component H5Dwrite " << endl;
          MPI_Abort(comm,ierr);
        }
        */
        ierr = H5Sclose(dataspace_id);
        ierr = H5Dclose(dataset_id);
        if (debug)
        {
          char msg[1000];
          sprintf(msg, "Wrote %s array, patch %d, rank %d\n", 
              field[v], p, myRank);
          cout << msg;
          cout.flush();
        }
      } // for v
      ierr = H5Pclose(prop_id);
      ierr = H5Gclose(grid_id); // Material_model_grid_XX group

      /*
      for (int v=0; v < nvars; v++)
      {
        delete[] h5_array[v];
        h5_array[v] = NULL;
      }
      */
   }
   if (debug)
      cout << "Rank " << myRank << " closing group..." << endl;
   cout.flush();
   ierr = H5Gclose(group_id); // Material_model group
}


//-----------------------------------------------------------------------
void SfileHDF5::material_interpolate(vector<float*>& h5_array,
    float* zbot, float* ztop, hsize_t (&slice_dims)[3],
    sfile_breaks& brk, Sarray* gridz, float zmin, float gridh,
    vector<float>& var_min, vector<float>& var_max,
    Sarray& grho, Sarray& gmu, Sarray& glambda, Sarray& gqp, Sarray& gqs)
{
  bool debug=false;
  const bool topo = (gridz != NULL);
  const float tol = gridh*1e-2; // relative
  const int nk = slice_dims[2];
  const int nvars = h5_array.size();
  // Loop over the grid, if we've stepped over a patch k point fill it in
  int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   //   if( myRank == 1 )
   //   {
   //      cout << "slice dims " << slice_dims[0] << " " << slice_dims[1] << " " << slice_dims[2] << endl;
   //      cout << "brks dims" << brk.ib << " " << brk.ie << " " << brk.jb << " " << brk.je << " " << brk.kb << " " << brk.ke << endl;
   //  cout << " brk size " << brk.hs << " " << brk.vs << " " << brk.p << " " << brk.g << endl;
   //  cout <<"zbot " << zbot << " ztop = " << ztop << endl;
   //   }
   int ibeg, iend, jbeg, jend;
   get_patch_dims( brk, ibeg, iend, jbeg, jend );

   float omp_min[nvars], omp_max[nvars];
   for (int v=0; v < nvars; ++v)
   {
     omp_min[v] = 1e8;
     omp_max[v] = -1;
   }
   if (debug)
     cout << "Rank " << myRank << ", loop over [i,j]=[" << ibeg << ":" << iend 
       << ", " << jbeg << ":" << jend << "]" << endl;

#pragma omp parallel for reduction(max:omp_max) reduction(min:omp_min)
   for( int j=0 ; j < jend-jbeg+1 ;j++ )
      for( int i=0 ; i < iend-ibeg+1 ;i++ )
   //  for (int j=0; j < slice_dims[1]; ++j)
   //    for (int i=0; i < slice_dims[0]; ++i)
    {
      bool point_debug = (debug) && (brk.p==1) && (i==1) && ((j+jbeg)==17);
       // bool point_debug = true;
       //       bool point_debug= myRank ==1;
       // bool point_debug=false;
       //      int gi = brk.ib + i*brk.hs;
       //      int gj = brk.jb + j*brk.hs;
       int gi = (i+ibeg)*brk.hs+1;
       int gj = (j+jbeg)*brk.hs+1;
      size_t ijh5 = j + slice_dims[1]*i;
      float zt = ztop[ijh5]; // smaller positive value of depth at top
      float zb = zbot[ijh5];
      float h = (zb - zt) / (float) (nk-1);
      //      if (point_debug)
      //        cout << "grid=" << brk.g << ", zt=" << zt
      //          << ", zb=" << zb << ", h=" << h << endl;

      // Walk every point, identify if we can interpolate from grid
      for (int gk=brk.kb; gk < brk.ke; ++gk)
      {
	 if( point_debug )
	    cout << "gk-loop start " << gk << " gi,gj= " << gi << " " << gj << endl;
        float gz0 = (topo) ? gridz->Sarray::operator()(gi,gj,gk) 
          : (zmin + (gk-1)*gridh);
        float gz1 = (topo) ? gridz->Sarray::operator()(gi,gj,gk+1) 
          : (zmin + (gk)*gridh);
        int kmin = ceil((-tol + gz0 - zt)/h);
        int kmax = floor((-tol + gz1 - zt)/h);
        if (gk==(brk.ke-1)) // Catch any last points
          kmax = floor((tol + gz1 - zt)/h);
        float zmin = zt + kmin*h;
        float zmax = zt + kmax*h;
        if (point_debug)
          cout << "first pass, grid=" << brk.g << ", gk=" << gk 
            << ", gz0=" << gz0 << ", gz1=" << gz1 
            << ", kmin=" << kmin << ", kmax=" << kmax
            << ", zmin=" << zmin << ", zmax=" << zmax 
            << ", h=" << h << endl;
        if (kmin > kmax) // Catch single points
          kmin = kmax;
        if ((zmin < (gz0-tol)) && (kmin != 0)) 
        {
          kmin++;
          zmin = zt + kmin*h;
        }
        if (zmax > (gz1+tol))
        {
          kmax--;
          zmax = zt + kmax*h;
        }
        if (point_debug)
          cout << "updated grid=" << brk.g << ", gk=" << gk 
            << ", gz0=" << gz0 << ", gz1=" << gz1 
            << ", kmin=" << kmin << ", kmax=" << kmax
            << ", zmin=" << zmin << ", zmax=" << zmax 
            << ", h=" << h << endl;
        if ((kmin<0) || (kmax >= nk)) // out of range
          continue; 
        // Loop over valid k indexing
        for (int k=kmin; k <= kmax; ++k)
        {
          // Do the interpolation to this k point
	   if( point_debug )
	   {
	      cout << "i,j,k= " << i<<" " << j << " " << k << " (gi,gj,gk)=" << gi << " " << gj << " " << gk << endl;
	      cout << "array bounds " << grho.m_ib << " " << grho.m_ie << " " << grho.m_jb <<
		 " " << grho.m_je << " " << grho.m_kb << " " << grho.m_ke << endl;
	   }
          float t = (zt + k*h - gz0) / (gz1 - gz0);
          float rho = (1-t)*grho(gi,gj,gk)+t*grho(gi,gj,gk+1);
          float mu = (1-t)*gmu(gi,gj,gk)+t*gmu(gi,gj,gk+1);
          float lambda = (1-t)*glambda(gi,gj,gk)+t*glambda(gi,gj,gk+1);
          float qp = (1-t)*gqp(gi,gj,gk)+t*gqp(gi,gj,gk+1);
          float qs = (1-t)*gqs(gi,gj,gk)+t*gqs(gi,gj,gk+1);
          size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
          float cp = sqrt((2*mu + lambda)/rho);
          float cs = sqrt(mu/rho);
          h5_array[0][ijkh5]=rho; // rho, comp 0
          h5_array[1][ijkh5]=cp; // cp, comp 1
          if( point_debug )
              cout << "--> Cp[" << ijkh5 << "]=" << cp << endl;
          h5_array[2][ijkh5]=cs; // cs, comp 2
          omp_min[0] = min(omp_min[0], rho);
          omp_max[0] = max(omp_max[0], rho);
          omp_min[1] = min(omp_min[1], cp);
          omp_max[1] = max(omp_max[1], cp);
          omp_min[2] = min(omp_min[2], cs);
          omp_max[2] = max(omp_max[2], cs);
          if (nvars > 3)
          {
            h5_array[3][ijkh5]=qp; // qp, comp 3
            h5_array[4][ijkh5]=qs; // qs, comp 4
            omp_min[3] = min(omp_min[3], qp);
            omp_max[3] = max(omp_max[3], qp);
            omp_min[4] = min(omp_min[4], qs);
            omp_max[4] = max(omp_max[4], qs);
          }
        }
      }
#if 0
      // For testing
      for (int k=0; k < nk; ++k)
      {
        // size_t ijkh5 = i + slice_dims[0]*(j + slice_dims[1]*k);
        size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
        size_t ind = 1 + i + slice_dims[0]*(j + slice_dims[1]*k);
        h5_array[0][ijkh5]=ind;
        h5_array[1][ijkh5]=ind;
        h5_array[2][ijkh5]=ind;
        if (nvars > 3)
        {
          h5_array[3][ijkh5]=ind; // qp, comp 3
          h5_array[4][ijkh5]=ind; // qs, comp 4
        }
      }
#endif // #if 0
    }

  // Copy over the min/max values
  for (int v=0; v < nvars; ++v)
  {
    var_min[v] = omp_min[v];
    var_max[v] = omp_max[v];
  }
}

//-----------------------------------------------------------------------
void SfileHDF5::material_interpolate_2(vector<float*>& h5_array,
    float* zbot, float* ztop, hsize_t (&slice_dims)[3],
    sfile_breaks& brk, Sarray* gridz, float zmin, float gridh, 
    int npatch, int ngrids,
    Sarray& grho, Sarray& gmu, Sarray& glambda, Sarray& gqp, Sarray& gqs)
{
  bool debug=true;
  const bool topo = (gridz != NULL);
  const float tol = gridh*1e-2; // relative
  const int nk = slice_dims[2];
  const int nvars = h5_array.size();
  // Loop over the grid, if we've stepped over a patch k point fill it in
  int myRank;
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
  int ibeg, iend, jbeg, jend, kbeg, kend;
  get_patch_dims( brk, ibeg, iend, jbeg, jend );
  kbeg = 0;
  kend = nk-1;

  if (debug)
    cout << "Rank " << myRank << ", loop over [i,j,k]=[" << ibeg << ":" << iend 
      << ", " << jbeg << ":" << jend
      << ", " << kbeg << ":" << kend << "]" << endl;

  #pragma omp parallel for
  for( int j=0 ; j < jend-jbeg+1 ;j++ )
  {
    for( int i=0 ; i < iend-ibeg+1 ;i++ )
    {
      bool point_debug = (debug) && (brk.p==1) && (i+ibeg)==0 && (j+jbeg)==31;
      point_debug = (point_debug) || ((brk.p==2) && (i+ibeg)==0 && (j+jbeg)==70 && debug);
      // bool point_debug = true;
      //       bool point_debug= myRank ==1;
      // bool point_debug=false;
      //      int gi = brk.ib + i*brk.hs;
      //      int gj = brk.jb + j*brk.hs;
      int gi = (i+ibeg)*brk.hs+1;
      int gj = (j+jbeg)*brk.hs+1;
      size_t ijh5 = j + slice_dims[1]*i;
      float zt = ztop[ijh5]; // smaller positive value of depth at top
      float zb = zbot[ijh5];
      float h = (zb - zt) / (float) (nk-1);
      //      if (point_debug)
      //        cout << "grid=" << brk.g << ", zt=" << zt
      //          << ", zb=" << zb << ", h=" << h << endl;
      // Calculate the gzt and gzb for values in this break
      int gk=brk.kb;
      float gzt = (topo) ? gridz->Sarray::operator()(gi,gj,gk) 
        : (zmin + (gk-1)*gridh);
      gk=brk.ke;
      float gzb = (topo) ? gridz->Sarray::operator()(gi,gj,gk) 
        : (zmin + (gk-1)*gridh);

      // Walk every point, identify if we can interpolate from grid
      if( point_debug )
        cout << "k-loop start " << gi << " " << gj
          << ", grid=" << brk.g
          << ", zt=" << zt << ", zb=" << zb
          << ", h=" << h << endl;
      for (int k=0, gk=brk.kb; k < nk; ++k) // Start gk at brk.kb
      {
        // Calculate the z value of point k
        float zk = zt + k*h;
        bool above_top = ((zk <= (gzt-tol)) && (k < 3) && (brk.p == npatch-1) 
              && (brk.g == ngrids-1) && (gk==1));
        bool below_bot = ((zk >= (gzb+tol)) && (k > (nk-3)) && (brk.p == 0)
              && (brk.g == 0));
        bool interp = false;
        for (/* keep gk to speed up search */ ; gk < brk.ke; ++gk)
        {
          // Calculate the gz0 and gz1 for gk, gk+1
          float gz0 = (topo) ? gridz->Sarray::operator()(gi,gj,gk) 
            : (zmin + (gk-1)*gridh);
          float gz1 = (topo) ? gridz->Sarray::operator()(gi,gj,gk+1) 
            : (zmin + (gk)*gridh);
          float t;
          // if (in gz range + tol) 
          if ((zk > (gz0-tol)) && (zk < (gz1+tol)))
          { // interpolate, continue in k
            t = (zt + k*h - gz0) / (gz1 - gz0);
            interp = true;
          }
          // else if not in range, but at the top of domain
          else if (above_top)
          { // check we should use value at gk=1, continue in k
            t = 0; 
            interp = true;
          }
          // else if not in range, but at the bottom of domain
          else if (below_bot)
          { // check we should use value at gk=brk.ke, continue in k
            t = 1; 
            interp = true;
          }

          if (interp)
          { // interp from gk values!
            float rho = (1-t)*grho(gi,gj,gk)+t*grho(gi,gj,gk+1);
            float mu = (1-t)*gmu(gi,gj,gk)+t*gmu(gi,gj,gk+1);
            float lambda = (1-t)*glambda(gi,gj,gk)+t*glambda(gi,gj,gk+1);
            float qp = (1-t)*gqp(gi,gj,gk)+t*gqp(gi,gj,gk+1);
            float qs = (1-t)*gqs(gi,gj,gk)+t*gqs(gi,gj,gk+1);
            size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
            float cp = sqrt((2*mu + lambda)/rho);
            float cs = sqrt(mu/rho);
            h5_array[0][ijkh5]=rho; // rho, comp 0
            h5_array[1][ijkh5]=cp; // cp, comp 1
            if( point_debug )
              cout << "--> Cp[" << ijkh5 << "]=" << cp << endl;
            h5_array[2][ijkh5]=cs; // cs, comp 2
            if (nvars > 3)
            {
              h5_array[3][ijkh5]=qp; // qp, comp 3
              h5_array[4][ijkh5]=qs; // qs, comp 4
            }
            if (point_debug)
              cout << "interp from grid=" << brk.g 
                << ", gk=" << gk << ", gz0=" << gz0 << ", gz1=" << gz1 
                << ", patch=" << brk.p << ", k=" << k << ", zk=" << zk 
                << ", t=" << t << ", h=" << h << endl;
            break; // stop searching in gk
          }
          // else keep search gk
        }
        if (point_debug && !interp)
        {
          cout << "not found in grid=" << brk.g 
            << ", gkb=" << brk.kb << ", gke=" << brk.ke << ", patch=" << brk.p
            << ", k=" << k << ", zk=" << zk << ", h=" << h << endl;
        }
        if (interp)
          continue; // continue to next k point, else hopefully another grid
        else
          gk = brk.kb; // reset gk search
      } // k loop
    } // j loop
  } // i loop
  // TODO: outside this routine, if any are invalid on any grid, abort

#if 0
  // For testing
  for( int j=0 ; j < jend-jbeg+1 ;j++ )
    for( int i=0 ; i < iend-ibeg+1 ;i++ )
      for (int k=0; k < nk; ++k)
      {
        size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
        h5_array[0][ijkh5]=ijkh5+1;
        h5_array[1][ijkh5]=ijkh5+1;
        h5_array[2][ijkh5]=ijkh5+1;
        h5_array[3][ijkh5]=ijkh5+1;
        h5_array[4][ijkh5]=ijkh5+1;
      }
#endif // #if 0
}


//-----------------------------------------------------------------------
void SfileHDF5::patch_interface(vector<float*> z_bot, vector<float*> z_top, 
    hsize_t (&dims)[2], int p, int b, vector<int>& patch_nk, 
    vector<float_sw4>& mr_depth, int hs, int cibeg, int cjbeg, Sarray& z_topo)
{
  const bool debug=true;
  MPI_Comm comm = MPI_COMM_WORLD;
  int myRank;
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
  char msg[1000];

  int npatch = patch_nk.size();
  float_sw4 z_bottom = mr_depth[npatch-1]; // should be the bottom
  float* z = (b==0) ? z_bot[p] : z_top[p];
 
  // What mr_depth do we use?
  int d = npatch - 1 - (p + b);
  // Copy subsample of the topo grid values/depth into window_array
  if (p==npatch-1 && b==1) // top / topo
  {
#pragma omp parallel for
    for( int j=0 ; j < dims[1]; j++ )
      for( int i=0 ; i < dims[0]; i++ )
      {
        const size_t ind = j+dims[1]*i; // only 2D slice
        const int gi = (cibeg + i)*hs + 1;
        const int gj = (cjbeg + j)*hs + 1;
        const int gk = 1;
        z[ind]= z_topo(gi,gj,gk);
      }
  }
  else if (p==0 && b==0) // bottom cartesian interface
  {
#pragma omp parallel for
    for( int j=0 ; j < dims[1]; j++ )
      for( int i=0 ; i < dims[0]; i++ )
      {
        const size_t ind = j+dims[1]*i; // only 2D slice
        const int gi = (cibeg + i)*hs + 1;
        const int gj = (cjbeg + j)*hs + 1;
        const int gk = 1;
        z[ind]= z_bottom;
      }
  }
  else // else interp to depth between topo->bottom
  {
#pragma omp parallel for
    for( int j=0 ; j < dims[1]; j++ )
      for( int i=0 ; i < dims[0]; i++ )
      {
        const size_t ind = j+dims[1]*i; // only 2D slice
        const int gi = (cibeg + i)*hs + 1;
        const int gj = (cjbeg + j)*hs + 1;
        const int gk = 1;
        const float topo = z_topo(gi,gj,gk); // topo here
        const float totdep = z_bottom - topo; // total depth
        const float frac = mr_depth[npatch-1-p-b] / totdep; // frac of totdep
        z[ind]= frac*z_bottom + (1-frac)*topo;
      }
  }
}
 
//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_header(hid_t file_id, hid_t mpiprop_id, 
    float& h, float (&lonlataz)[3], vector<int>& patch_nk)
{
   bool debug=false;
   hid_t dataspace_id;
   hid_t dataset_id;
   herr_t ierr;
   // Only 1 rank needs to read these - then broadcast
   // if (myRank == 0)
   {
      dataset_id = H5Dopen2(file_id, "Coarsest horizontal grid spacing",
         H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, &h);
      ierr = H5Dclose(dataset_id);

      // Origin longitude, latitude, azimuth
      dataset_id = H5Dopen2(file_id, "Origin longitude, latitude, azimuth",
         H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, lonlataz);
      ierr = H5Dclose(dataset_id);

      //   Ngrids - int, number of 3D grids in the file
      int npatch;
      dataset_id = H5Dopen2(file_id, "ngrids", H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, &npatch);
      ierr = H5Dclose(dataset_id);

      patch_nk.resize(npatch,-1);
      dataset_id = H5Dopen2(file_id, "grid nz", H5P_DEFAULT);
      ierr = H5Dread(dataset_id, H5T_STD_I32LE, H5S_ALL, H5S_ALL,
                      mpiprop_id, patch_nk.data());
      ierr = H5Dclose(dataset_id);
      ASSERT(patch_nk.size() == npatch);
      for (int p=0; p < npatch; ++p)
        ASSERT(patch_nk[p] > 1);

      h /= (float) pow(2,npatch-1);
      if (debug)
      {
        sfile_hdr hdr;
        hdr.ngrids = npatch;
        hdr.h = h;
        hdr.lon0 = lonlataz[0];
        hdr.lat0 = lonlataz[1];
        hdr.azim = lonlataz[2];
        cout << "horizontal grid spacing: " << hdr.h << endl;
        cout << "ngrids: " << hdr.ngrids << endl;
        cout << "longitude: " << hdr.lon0 << endl;
        cout << "latitude: " << hdr.lat0 << endl;
        cout << "azimuth: " << hdr.azim << endl;
        cout << endl;
      }
   }
}

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_interface_group(hid_t file_id, hid_t mpiprop_id, 
    bool topoOnly, vector<Sarray*>& intf)
{
   bool debug=false;
   char msg[1000];
   MPI_Comm comm = MPI_COMM_WORLD;
   int myRank;
   MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
   if (debug)
      cout << "Rank " << myRank << ", SfileHDF5::read_sfile_interfaces" << endl;

   hid_t dataspace_id;
   hid_t dataset_id;
   herr_t ierr;

   char group_name[] = "Z_interfaces";
   // Open 2D just for top topo “interface”
   // int g = npatch;
   // int ig = ew.mNumberOfGrids-1; // TODO - if we're going to window reads
   int nintf = intf.size();
   ASSERT(nintf > 0);
   for (int f=(topoOnly) ? (nintf-1) : 0; f < nintf; ++f)
   {
      Sarray& gridElev = *intf[f];
      // Open the dataset for z field
      char buff[100];
      sprintf(buff, "/%s/z_values_%d", group_name, f);
      dataset_id = H5Dopen2(file_id, buff, H5P_DEFAULT);
      if (dataset_id < 0)
      {
         cout << "Could not open dataset: " << buff << endl;
         MPI_Abort(comm, file_id);
      }
      //  Read the size of the data set
      hid_t dataspace_id = H5Dget_space(dataset_id);
      const hsize_t z_dim = 2; // 2D data
      hsize_t dims[z_dim]; // 2D data
      H5Sget_simple_extent_dims(dataspace_id, dims, NULL);
      if (debug)
      {
        cout << "z grid " << f << " size (" << dims[0]
          << ", " << dims[1] << ")" << endl;
      }

      // Z interface values
      hsize_t slice_dims[z_dim], global_dims[z_dim];
      // Read all the points
      // TODO, this could be windowed for this processor
      global_dims[0] = dims[0];
      global_dims[1] = dims[1];
      slice_dims[0] = dims[0];
      slice_dims[1] = dims[1];
      // Allocate our tmp array on first pass, biggest grid
      gridElev.define(1,dims[0],1,dims[1],1,1);
      size_t npts = (size_t)(slice_dims[0] * slice_dims[1]);
      float window_array[npts];

      // Modify dataset read properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      // ierr = H5Pset_chunk(prop_id, z_dim, slice_dims);

      // TODO - read the topo data
      hsize_t start[2] = {0, 0};
      start[0] = 0;
      start[1] = 0;
      if (debug)
      {
         sprintf(msg, "Rank %d, selecting interface %d z hyperslab = %d %d, size [%d,%d] in [%d,%d] \n",
                 myRank, f, (int)start[0], (int)start[1],
                 (int)slice_dims[0], (int)slice_dims[1],
                 (int)global_dims[0], (int)global_dims[1]);
         cout << msg;
         cout.flush();
      }
      hid_t window_id = H5Screate_simple(z_dim, slice_dims, NULL);
      ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, NULL,
          slice_dims, NULL);
      if (ierr < 0)
      {
        cout << "Error from z H5Sselect_hyperslab" << endl;
        MPI_Abort(comm,ierr);
      }
      if (debug)
      {
        char msg[1000];
        sprintf(msg, "Reading z array Rank %d\n", myRank);
        cout << msg;
        cout.flush();
      }

      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, window_id, dataspace_id,
          mpiprop_id, window_array);
      if (ierr < 0)
      {
        cout << "Error from SfileHDF5 interface H5Dread " << endl;
        MPI_Abort(comm,ierr);
      }

      const int k=1;
      float d_min = 1e8;
      float d_max = -1e8;

#pragma omp parallel for
      for( int i=0 ; i < slice_dims[0]; i++ )
      for( int j=0 ; j < slice_dims[1]; j++ )
      {
         size_t ind = j+slice_dims[1]*i; // only 2D slice
         int gi = i + 1;
         int gj = j + 1;
         float depth = -window_array[ind]; // depth = -elev
         gridElev(gi,gj,k) = depth;
         d_min = min(depth, d_min);
         d_max = max(depth, d_max);
         // window_array[ind]= (double) ind; // for testing
      }
      if (debug)
        cout << "Topo depth min=" << d_min << ", max="  << d_max << endl;

      ierr = H5Pclose(prop_id);
      ierr = H5Dclose(dataset_id);
      ierr = H5Sclose(dataspace_id);
   }
}

//-----------------------------------------------------------------------
void SfileHDF5::read_sfile_material_group(hid_t file_id, hid_t mpiprop_id, 
    int nghost, int nvars, vector<Sarray>& matl)
{
  bool debug=false;
  char msg[1000];
  MPI_Comm comm = MPI_COMM_WORLD;
  int myRank;
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);
  if (debug)
    cout << "Rank " << myRank << ", SfileHDF5::read_sfile_material_group" << endl;

  hid_t dataspace_id;
  hid_t dataset_id;
  herr_t ierr;
  char group_name[] = "Material_model";
  const char *field[] = {"Rho", "Cp", "Cs", "Qp", "Qs"};

  int npatch = matl.size();
  ASSERT(npatch > 0);
  float minval[npatch][nvars],maxval[npatch][nvars];
  for (int p=0; p < npatch; ++p)
  {
    Sarray& data = matl[p];
    for (int v=0; v < nvars; ++v)
    {
      // Open the dataset for each material field
      char buff[100];
      sprintf(buff, "/%s/grid_%d/%s", group_name, p, field[v]);
      dataset_id = H5Dopen2(file_id, buff, H5P_DEFAULT);
      if (dataset_id < 0)
      {
         cout << "Could not open dataset: " << buff << endl;
         MPI_Abort(comm, file_id);
      }
      //  Read the size of the data set
      hid_t dataspace_id = H5Dget_space(dataset_id);
      const hsize_t dim = 3; // 3D data
      hsize_t dims[dim]; // 3D data
      H5Sget_simple_extent_dims(dataspace_id, dims, NULL);
      if (debug)
      {
        cout << "Material patch " << p << ", variable " << field[v]
          << ", size=(" << dims[0] << ", " << dims[1] << ", " 
          << dims[2] << ")" << endl;
      }
      // Adjust the bounds, and set the start/slice size to read
      int ib,ie,jb,je,kb,ke; // relative to h5 data, 0 offset
      ib = max(data.m_ib-1,0);
      ie = min(data.m_ie-1,(int) dims[0]-1);
      jb = max(data.m_jb-1,0);
      je = min(data.m_je-1,(int) dims[1]-1);
      kb = max(data.m_kb-1,0);
      ke = min(data.m_ke-1,(int) dims[2]-1);
      // Read all the points for this processor
      hsize_t slice_dims[dim], global_dims[dim], start[dim];
      global_dims[0] = dims[0];
      global_dims[1] = dims[1];
      global_dims[2] = dims[2];
      slice_dims[0] = ie - ib + 1;
      slice_dims[1] = je - jb + 1;
      slice_dims[2] = ke - kb + 1;
      start[0] = ib;
      start[1] = jb;
      start[2] = kb;
      size_t npts = (size_t)(slice_dims[0] * slice_dims[1] * slice_dims[2]);
      float* window_array = new float[npts];

      // Modify dataset read properties to enable chunking
      hid_t prop_id = H5Pcreate(H5P_DATASET_CREATE);
      // ierr = H5Pset_chunk(prop_id, z_dim, slice_dims);

      // Read the data into it
      if (debug)
      {
         sprintf(msg, "Rank %d, selecting material %s, patch %d, start [%d,%d,%d], size [%d,%d,%d] in [%d,%d,%d]\n",
             myRank, field[v], p, (int)start[0], (int)start[1], (int)start[2],
             (int)slice_dims[0], (int)slice_dims[1], (int)slice_dims[2],
             (int)global_dims[0], (int)global_dims[1], (int)global_dims[2]);
         cout << msg;
         cout.flush();
      }
      hid_t window_id = H5Screate_simple(dim, slice_dims, NULL);
      ierr = H5Sselect_hyperslab(dataspace_id, H5S_SELECT_SET, start, NULL,
          slice_dims, NULL);
      if (ierr < 0)
      {
        cout << "Error from material H5Sselect_hyperslab" << endl;
        MPI_Abort(comm,ierr);
      }
      if (debug)
      {
        cout << "Reading material array Rank " << myRank << endl;
        cout.flush();
      }

      ierr = H5Dread(dataset_id, H5T_IEEE_F32LE, window_id, dataspace_id,
          mpiprop_id, window_array);
      if (ierr < 0)
      {
        cout << "Error from SfileHDF5 interface H5Dread " << endl;
        MPI_Abort(comm,ierr);
      }
      float mintmp=1e38;
      float maxtmp=-1e38;
#pragma omp parallel for reduction(min:mintmp) reduction(max:maxtmp)
      for( int i=0 ; i < slice_dims[0]; i++ )
      for( int j=0 ; j < slice_dims[1]; j++ )
      for( int k=0 ; k < slice_dims[2]; k++ )
      {
         size_t ijkh5 = k + slice_dims[2]*(j + slice_dims[1]*i);
         int gi = i + 1 + ib;
         int gj = j + 1 + jb;
         int gk = k + 1 + kb;
         float val = window_array[ijkh5];
         data(v+1,gi,gj,gk) = val;
         mintmp = min(val, mintmp);
         maxtmp = max(val, maxtmp);
      }
      minval[p][v]=mintmp;
      maxval[p][v]=maxtmp;
      delete[] window_array;
      ierr = H5Sclose(window_id);
      ierr = H5Pclose(prop_id);
      ierr = H5Dclose(dataset_id);
      ierr = H5Sclose(dataspace_id);
    }
  }
  float min_glb[npatch][nvars], max_glb[npatch][nvars];
  MPI_Reduce(minval, min_glb, npatch*nvars, MPI_FLOAT, MPI_MIN, 0, MPI_COMM_WORLD );
  MPI_Reduce(maxval, max_glb, npatch*nvars, MPI_FLOAT, MPI_MAX, 0, MPI_COMM_WORLD );
  if (myRank == 0)
  {
    for (int p=0; p < npatch; ++p)
    for (int v=0; v < nvars; ++v)
      cout << "Material patch " << p << " variable " << field[v]
        << " min=" << min_glb[p][v] << ", max="  << max_glb[p][v] << endl;
  }
}

//-----------------------------------------------------------------------
void SfileHDF5::calculate_grid_boundingbox(EW& ew, float_sw4 (&bb)[3][2])
{
  // Figure out bounding box in this processor
  float_sw4 xmin=1e38, xmax=-1e38, ymin=1e38, ymax=-1e38, zmin=1e38, zmax=-1e38;
  int g=ew.mNumberOfGrids-1;
  float_sw4 h=ew.mGridSize[g];
  if( xmin > (ew.m_iStartInt[g]-1)*h )
    xmin =  (ew.m_iStartInt[g]-1)*h;
  if( xmax < (ew.m_iEndInt[g]-1)*h )
    xmax =  (ew.m_iEndInt[g]-1)*h;
  if( ymin > (ew.m_jStartInt[g]-1)*h )
    ymin =  (ew.m_jStartInt[g]-1)*h;
  if( ymax < (ew.m_jEndInt[g]-1)*h )
    ymax =  (ew.m_jEndInt[g]-1)*h;
  if( ew.topographyExists() && g == ew.mNumberOfGrids-1 )
  {
     int kb=ew.m_kStartInt[g];
     for( int j=ew.m_jStartInt[g] ; j <= ew.m_jEndInt[g] ; j++ )
        for( int i=ew.m_iStartInt[g] ; i <= ew.m_iEndInt[g] ; i++ )
           if( zmin > ew.mZ(i,j,kb) )
              zmin = ew.mZ(i,j,kb);
  }
  else
  {
     if( zmin > (ew.m_kStartInt[g]-1)*h + ew.m_zmin[g] ) 
        zmin = (ew.m_kStartInt[g]-1)*h + ew.m_zmin[g];
  }
  zmax = (ew.m_kEnd[0]-1)*h + ew.m_zmin[0]; // bottom of the domain
  bb[0][0] = xmin;
  bb[0][1] = xmax;
  bb[1][0] = ymin;
  bb[1][1] = ymax;
  bb[2][0] = zmin;
  bb[2][1] = zmax;
}

//-----------------------------------------------------------------------
void SfileHDF5::calculate_interpolation_patch(vector<Sarray>& matl, 
    int nghost, float_sw4 (&bb)[3][2], float_sw4 x0, float_sw4 y0, 
    float hh, int nvars, vector<int>& patch_nk)
{
  bool debug=false;
  MPI_Comm comm = MPI_COMM_WORLD;
  int myRank;
  MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

  // Calculate the Sarray bounds relative to the Sfile origin, grid spacing
  int npatch = patch_nk.size();
  for (int p=0; p < npatch; ++p)
  {
    float h = hh * pow(2,npatch-1-p); // horizontal grid spacing doubles
    float tol = 1e-2;
    int gis,gie,gjs,gje,gks,gke; // start and end SW4 indices for each dimension
    gis = static_cast<int>(floor(1 + (bb[0][0]-x0)/h + tol))-nghost;
    gie = static_cast<int>(ceil(1 + (bb[0][1]-x0)/h - tol))+nghost;
    gjs = static_cast<int>(floor(1 + (bb[1][0]-y0)/h + tol))-nghost;
    gje = static_cast<int>(ceil(1 + (bb[1][1]-y0)/h - tol))+nghost;
    // k indices are determined from interfaces, catch out-of-bounds later
    gks = 1;
    gke = patch_nk[p];
    Sarray& data = matl[p];
    data.define(nvars,gis,gie,gjs,gje,gks,gke);
    if (debug)
    {
      cout << "Rank " << myRank << " on SW4 domain:" 
        << " x=(" << bb[0][0] << ", " << bb[0][1] << "), "
        << " y=(" << bb[1][0] << ", " << bb[1][1] << "), "
        << " z=(" << bb[2][0] << ", " << bb[2][1] << "), " << endl
        << "--> Sfile patch " << p << " grid spacing h=" << h
        << ", sw4 indices:" << " i=(" << data.m_ib << ", " << data.m_ie << "), "
        << " j=(" << data.m_jb << ", " << data.m_je << "), "
        << " k=(" << data.m_kb << ", " << data.m_ke << "), nghost=" 
        << nghost << endl;
      cout.flush();
    }
  }
}

#endif // ifdef USE_HDF5


